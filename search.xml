<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TCP/IP TIME_WAIT过多]]></title>
    <url>%2F2018%2F01%2F12%2Ftime_wait%2F</url>
    <content type="text"><![CDATA[TCP/IP TIME_WAIT状态原理和服务端过多原因分析，及解决方案。 分析：http://lib.csdn.net/article/computernetworks/17275http://blog.csdn.net/bk_guo/article/details/53995399windows下解决：http://www.cnblogs.com/doNetTom/p/5160709.html]]></content>
      <categories>
        <category>exception</category>
      </categories>
      <tags>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thrift学习]]></title>
    <url>%2F2017%2F12%2F06%2Fthrift%2F</url>
    <content type="text"><![CDATA[自己一些总结 简介Thrift是Facebook的一个开源项目，用于RPC通信，C/S结构，跨语言的IDL（Interface Description Language）。 Thrift安装1、windows安装：从 http://thrift.apache.org/download 下载thrift-0.10.0.exe，然后重命名为thrift.exe,放到任意目录下（如：E:\thrift\0.10.0）,将目录添加到环境变量中。cmd中执行thrift -version。2、IDEA安装插件：插件安装完成，打开File-&gt;settings-&gt;Thrift compiler，(1)填写Thrift executable: thrift,(2)勾选Allow negative field keys。3、maven项目：打开File-&gt;Project Structure-&gt;Facets,添加Thrift，右边添加java，设置输出目录。参考：http://blog.csdn.net/haluoluo211/article/details/53786381 实例1、Apache Thrift - 可伸缩的跨语言服务开发框架2、Thrift入门及Java实例演示 阻塞式： 服务端：（单线程TSimpleServer、多线程TThreadPoolServer）非阻塞式： 服务端服务模型：（TNonblockingServer、半同步半异步THsHaServer） 客户端还支持：异步客户端 服务端和客户端需要指定 TFramedTransport 数据传输的方式 进阶连接池Thrift客户端连接池设计实现Thrift客户端连接池thrift无法判断连接失效的原因与解决方案 [Thrift连接池，spring配置化，透明化调用（优化2）]http://blog.csdn.net/zjs40/article/details/63265407 双向通信[双向异步远程调用]http://blog.csdn.net/qq_27989757/article/details/50725973http://www.bkjia.com/Javabc/1173043.html http://blog.csdn.net/june905206961/article/details/54890460 参考你应该知道的 RPC 原理 http://m.blog.csdn.net/dream_lixiang/article/details/54603374]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>thrift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap]]></title>
    <url>%2F2017%2F11%2F26%2Fbootstrap%2F</url>
    <content type="text"><![CDATA[这里主要记录前端页面的问题。 要写个官网，好吧，此处简单记录下。 简单css1、透明：rgba(255, 135, 36, 0.9)2、垂直居中：12345.center-vertical &#123; position: relative; top: 50%; transform: translateY(-50%);&#125; 3、背景图片：12345678.bg-img &#123; background: url(../images/banner-about.png); background-position: center 0; /*屏小，背景居中*/ background-repeat: no-repeat; /*背景图像将仅显示一次，不重复*/ background-attachment: fixed; /*设置固定的背景图像*/ background-size: cover; -webkit-background-size: cover;&#125; 4、公司发展历程（台阶上坡式）：使用bootstrap的列偏移：http://v3.bootcss.com/css/ 滚动翻页整个界面分N屏，垂直滚动。示例：http://www.swiper.com.cn/demo/090-vertical.html ， 使用的是swiper4：http://www.swiper.com.cn/1234var mySwiper = new Swiper(&apos;.swiper-container&apos;, &#123; direction: &apos;vertical&apos;, mousewheel: true,&#125;) 返回顶部1234567&lt;!-- 第一种 --&gt;&lt;a href=&quot;javascript:void(0);&quot; onclick=&quot;slideToTop();&quot;&gt;&lt;i class=&quot;fa fa-arrow-up&quot;&gt;&lt;/i&gt;&lt;/a&gt;function slideToTop() &#123; mySwiper.slideTo(0, 1000, false); //切换到第一个slide，速度为1秒&#125;&lt;!-- 第二种 --&gt;&lt;a href=&quot;javascript:scroll(0,0)&quot;&gt;&lt;i class=&quot;fa fa-arrow-up&quot;&gt;&lt;/i&gt;&lt;/a&gt; 图片动态1、鼠标移至图片上，下方展开内容。使用slideUp()，slideDown();2、图片底部透明遮罩文字标题效果：http://www.qdxw.net/xwhtml/559.html 背景图满屏12345678910111213141516171819202122232425262728&lt;html&gt;&lt;meta charset=&quot;UTF-8&quot; http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;title&gt;背景图宽度高度满屏&lt;/title&gt;&lt;style&gt;.index_bgimg&#123; width: 100%; height: 100%; /*height: 1079px;*/ background: url(../img/bg_img.png); background-position: center 0; /*屏小，背景居中*/ background-repeat: no-repeat; /*背景图像将仅显示一次，不重复*/ background-attachment: fixed; /*设置固定的背景图像*/ background-size: cover; -webkit-background-size: cover;&#125;&lt;/style&gt;&lt;body&gt; &lt;!-- &lt;div id=&quot;Layer1&quot; style=&quot;position:absolute; left:0px; top:0px; width:100%; height:100%&quot;&gt; &lt;img src=&quot;1.png&quot; width=&quot;100%&quot; height=&quot;100%&quot;/&gt; &lt;/div&gt; --&gt; &lt;div id=&quot;Layer1&quot; style=&quot;position:absolute; left:0px; top:0px; width:100%; height:100%&quot;&gt; &lt;div class=&quot;index_bgimg&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt; &lt;/div&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 滚动条样式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950*&#123; scrollbar-face-color:rgba(0,0,0,0.2); !*面子*! scrollbar-arrow-color:rgba(0,0,0,0.2); !*箭头*! scrollbar-3dlight-color:rgba(0,0,0,0.2); !*最外左*! scrollbar-highlight-color:rgba(0,0,0,0.2); !*左二*! scrollbar-shadow-color:rgba(0,0,0,0.2); !*右二*! scrollbar-darkshadow-color:rgba(0,0,0,0.2); !*右一*! scrollbar-track-color:rgba(0,0,0,0.2); !*滑道*!&#125;!*滚动条整体*!::-webkit-scrollbar&#123; width: 4px; !*高宽分别对应横竖滚动条的尺寸*! height: 4px;&#125;!*滚动条按钮*!::-webkit-scrollbar-button &#123;&#125;::-webkit-scrollbar-track&#123; -webkit-box-shadow: inset 0 0 5px rgba(0,0,0,0.2); border-radius: 0; background: rgba(0,0,0,0.2);&#125;::-webkit-scrollbar-track-piece&#123; background-color:rgba(0,0,0,0.2); !*滑道*! -webkit-border-radius:4px; !*滑道圆角宽度*!&#125;::-webkit-scrollbar-thumb&#123; border-radius: 5px; -webkit-box-shadow: inset 0 0 5px rgba(0,0,0,0.2); background: rgba(0,0,0,0.2); !*background-color:#F3F3F3; !*滑动条表面*!*! !*border:solid 1px #C0C0C0; !*滑动条边框*!*! !*border-radius:4px; !*滑动条圆角宽度*!*!&#125;!*横竖滚动条交角*!::-webkit-scrollbar-corner &#123; background-color: rgba(0,0,0,0.2);&#125;!*横竖滚动条交角图案*!::-webkit-resizer &#123; !*background-image: url(/public/img/resizer-inactive.png);*! background-repeat: no-repeat; background-position: bottom right;&#125;!*鼠标滑过滑动条*!::-webkit-scrollbar-thumb:hover&#123; background-color:rgba(0,0,0,0.2);&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot源码学习]]></title>
    <url>%2F2017%2F11%2F20%2Fspringboot-source%2F</url>
    <content type="text"><![CDATA[springboot源码学习 参考http://zhaox.github.io/java/2016/03/22/spring-boot-start-flowhttp://www.cnblogs.com/davidwang456/p/5846513.htmlhttp://www.majunwei.com/view/201708262210563675.html]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[protobuf的学习]]></title>
    <url>%2F2017%2F11%2F16%2Fprotobuf%2F</url>
    <content type="text"><![CDATA[开始学习pb了，来些总结吧！本人github上本内容相关的项目： springboot+protobuf springboot+protobuf+websocket接口设计： 我的Protobuf消息设计原则 https://my.oschina.net/cxh3905/blog/159122 我的Protobuf消息设计原则(续)–实践 https://my.oschina.net/cxh3905/blog/293000 Json转换protobuf转json123456789101112131415161718192021222324252627import com.google.protobuf.Descriptors;import com.googlecode.protobuf.format.JsonFormat;import java.io.IOException;/** * JsonFormat的子类，不打印图片数据 * * 直接使用com.googlecode.protobuf.format.JsonFormat的方法： * new JsonFormat().printToString(message); * 来打印，会将图片也打印出来，下面方法过滤了图片数据。 * new MyJsonFormat().printToString(message); * * Created by hfy on 2018/1/5. */public class MyJsonFormat extends JsonFormat &#123; @Override public void printField(Descriptors.FieldDescriptor field, Object value, JsonGenerator generator) throws IOException &#123; if (field.getType() == Descriptors.FieldDescriptor.Type.BYTES) &#123; generator.print(&quot;\&quot;&quot;); generator.print(&quot;image data...&quot;); generator.print(&quot;\&quot;&quot;); &#125; else &#123; super.printField(field, value, generator); &#125; &#125;&#125; 参考protobuf 和 intellij 配置使用Protobuf 语法指南httpclient ＋protobuf 实现数据传输]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[死锁]]></title>
    <url>%2F2017%2F10%2F27%2Fexception-deadlock%2F</url>
    <content type="text"><![CDATA[项目遇到的死锁问题 项目假死问题描述： 在linux服务器中，springboot项目运行一段时间后，ps -ef|grep java发现项目进程在，但是打开日志，请求项目接口，发现服务器没有反应，好像死了一样。什么原因呢？解决： 问题出现后，通过 jstack 进程id 发现，出现了死锁问题。1234567891011121314151617181920212223242526272829303132333435363738394041JNI global references: 296Found one Java-level deadlock:=============================&quot;http-nio-8889-exec-34&quot;: waiting to lock monitor 0x00007fe2c45001d8 (object 0x0000000086bef5e8, a com.hfy.service.impl.SessionServiceImpl), which is held by &quot;SockJS-1&quot;&quot;SockJS-1&quot;: waiting to lock monitor 0x00007fe2d424ec98 (object 0x0000000086bef5c8, a com.hfy.service.impl.TokenServiceImpl), which is held by &quot;SockJS-2&quot;&quot;SockJS-2&quot;: waiting to lock monitor 0x00007fe2c45001d8 (object 0x0000000086bef5e8, a com.hfy.service.impl.SessionServiceImpl), which is held by &quot;SockJS-1&quot;Java stack information for the threads listed above:===================================================&quot;http-nio-8889-exec-34&quot;: at com.hfy.service.impl.SessionServiceImpl.keepAlive(SessionServiceImpl.java:114) - waiting to lock &lt;0x0000000086bef5e8&gt; (a com.hfy.service.impl.SessionServiceImpl) at com.hfy.PmWebSocketHandler.handleTextMessage(PmWebSocketHandler.java:85) - locked &lt;0x00000000d8ca01c8&gt; (a org.springframework.web.socket.adapter.standard.StandardWebSocketSession) ............&quot;SockJS-1&quot;: at com.hfy.service.impl.TokenServiceImpl.deleteToken(TokenServiceImpl.java:49) - waiting to lock &lt;0x0000000086bef5c8&gt; (a com.hfy.service.impl.TokenServiceImpl) ............ at com.hfy.service.impl.SessionServiceImpl.sessionTimeout(SessionServiceImpl.java:96) - locked &lt;0x0000000086bef5e8&gt; (a com.hfy.service.impl.SessionServiceImpl) at com.hfy.service.ScheduleTask.sessionTimeout(ScheduleTask.java:75) .......&quot;SockJS-2&quot;: at com.hfy.service.impl.SessionServiceImpl.deleteSession(SessionServiceImpl.java:47) - waiting to lock &lt;0x0000000086bef5e8&gt; (a com.hfy.service.impl.SessionServiceImpl) ............ at com.hfy.service.impl.TokenServiceImpl.tokenTimeout(TokenServiceImpl.java:80) - locked &lt;0x0000000086bef5c8&gt; (a com.hfy.service.impl.TokenServiceImpl) at com.hfy.service.ScheduleTask.tokenTimeout(ScheduleTask.java:69) .......Found 1 deadlock. 可以很清楚的看到： “SockJS-2”: TokenServiceImpl.java:80执行tokenTimeout()的时候，获得了锁,方法执行到了SessionServiceImpl.java:47,执行deleteSession时，等待锁 “SockJS-1”: SessionServiceImpl.java:96执行sessionTimeout()的时候，获得了锁,方法执行到了TokenServiceImpl.java:49，执行deleteToken时，等待锁 典型的死锁，知道问题所在，解决去了。。。。。。 Tomcat一个BUG造成CLOSE_WAIT此问题还未遇见http://cxytiandi.com/blog/detail/11147http://www.cnblogs.com/saaav/p/6258831.html]]></content>
      <categories>
        <category>exception</category>
      </categories>
      <tags>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[websocket相关问题]]></title>
    <url>%2F2017%2F10%2F26%2Fwebsocket%2F</url>
    <content type="text"><![CDATA[自己一些总结 UnresolvedAddressException 连接 Connecting to WebSocket at ws://www.hfy.com:8888/testSvr，结果出现异常：UnresolvedAddressException 检测发现dns配置正确。后来原因是：服务器连接数已达到上限 BINARY_PARTIAL_WRITING 此问题的原因是：多线程在同时发送消息。需要加锁。以下是错误代码：1234567891011@Overrideprotected void handleBinaryMessage(WebSocketSession session, BinaryMessage message) throws Exception &#123; Thread.sleep(1 * 1000); UserProtos.User user = UserProtos.User.parseFrom(message.getPayload()); System.out.println(user.getName()); try &#123; session.sendMessage(message); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 强制关闭现有连接 对此进行改进以后,还是报错：java.io.IOException: java.io.IOException: 远程主机强迫关闭了一个现有的连接。发送之前判断session是否打开。 session突然关闭，handler的handleTextMessage方法还是会接收到消息的。所有数据处理之前，可以使用session.isOpen()来判断session的状态。123456789101112@Overrideprotected void handleBinaryMessage(WebSocketSession session, BinaryMessage message) throws Exception &#123; UserProtos.User user = UserProtos.User.parseFrom(message.getPayload()); System.out.println(user.getName()); try &#123; if (session.isOpen()) &#123; session.sendMessage(message); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; timeoutException 同时发现会报错：WritePendingException 这种问题在服务端处理的比较慢的时候出现。 为了更改的找出问题所在，客户端一秒发送100条数据，服务端一秒钟处理一条数据（线程休眠），出现此问题。 因为：很多数据存储在缓存中，无法继续写入，超时。 至于写绑定异常，本人认为是：超时关闭，写入关闭原因，而之前的数据超时没写完，两个一起写造成的。 websocket超时断开 两个socket间，如果不长时间进行通信，会自动断开。虽然断开可以接收到通知，但是还有路由等原因会导致断开，是接不到通知的，察觉不到。一端认为还在，另一端已经断开了。解决办法： 发送心跳包 IOException:Too many open files服务器无法联网，websocket连接其他服务器，报错UnresolvedAddressException：123456789java.nio.channels.UnresolvedAddressException: null at sun.nio.ch.Net.checkAddress(Net.java:101) ~[na:1.8.0_101] at sun.nio.ch.UnixAsynchronousSocketChannelImpl.implConnect(UnixAsynchronousSocketChannelImpl.java:301) ~[na:1.8.0_101] at sun.nio.ch.AsynchronousSocketChannelImpl.connect(AsynchronousSocketChannelImpl.java:199) ~[na:1.8.0_101] at org.apache.tomcat.websocket.WsWebSocketContainer.connectToServer(WsWebSocketContainer.java:297) ~[tomcat-embed-websocket-8.5.16.jar!/:8.5.16] at org.springframework.web.socket.client.standard.StandardWebSocketClient$1.call(StandardWebSocketClient.java:150) ~[spring-websocket-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.socket.client.standard.StandardWebSocketClient$1.call(StandardWebSocketClient.java:147) ~[spring-websocket-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[na:1.8.0_101] at java.lang.Thread.run(Thread.java:745) [na:1.8.0_101] 没有联网，报错正常，但是运行一段时间后，报了以下错误。12345672017-11-21 05:30:00,010:ERROR http-nio-8888-Acceptor-0 (DirectJDKLog.java:181) - Socket accept failedjava.io.IOException: Too many open files at sun.nio.ch.ServerSocketChannelImpl.accept0(Native Method) ~[?:1.8.0_101] at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:422) ~[?:1.8.0_101] at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:250) ~[?:1.8.0_101] at org.apache.tomcat.util.net.NioEndpoint$Acceptor.run(NioEndpoint.java:457) [tomcat-embed-core-8.5.4.jar!/:8.5.4] at java.lang.Thread.run(Thread.java:745) [?:1.8.0_101] 查看进程号：ps -ef | grep java 再用命令lsof -p 进程号 | wc -l发现打开的文件数量很多。lsof -p 进程号则发现有大量类似的：1java 13597 root 51u sock 0,6 0t0 185981 can&apos;t identify protocol What？什么原因？网络搜索查看原因，解释说socket没有关闭。定位到打开socket的地方，只是简单的下面几行：12345StandardWebSocketClient client = new StandardWebSocketClient();WebSocketConnectionManager manager = new WebSocketConnectionManager( client, handler, WS_URI);manager.setOrigin(ORIGIN);manager.start(); 不明白，查看源码，追踪到WsWebSocketContainer中，1234567891011121314151617181920212223242526272829303132public Session connectToServer(Endpoint endpoint, ClientEndpointConfig clientEndpointConfiguration, URI path) throws DeploymentException &#123; // ...... // Open the connection Future&lt;Void&gt; fConnect = socketChannel.connect(sa); AsyncChannelWrapper channel = null; // ...... if (secure) &#123; SSLEngine sslEngine = createSSLEngine(userProperties); channel = new AsyncChannelWrapperSecure(socketChannel, sslEngine); &#125; else if (channel == null) &#123; channel = new AsyncChannelWrapperNonSecure(socketChannel); &#125; try &#123; // ...... &#125; catch (ExecutionException | InterruptedException | SSLException | EOFException | TimeoutException | URISyntaxException e) &#123; throw new DeploymentException( sm.getString(&quot;wsWebSocketContainer.httpRequestFailed&quot;), e); &#125; finally &#123; if (!success) &#123; channel.close(); &#125; &#125; // ......&#125; channel.close()实则关闭的就是socketChannel，所以，如果直接写ip，没事，写域名连接，每次报错在connect(sa)处报错，没有关闭。解决： 在调用创建socket连接之前，判断了下是否可以连接。 参考http://www.cnblogs.com/highriver/archive/2012/01/16/2324035.htmlhttps://my.oschina.net/ldl123292/blog/304360Spring Websocket Session共享解决思路（背景）http://www.sojson.com/blog/238.html看完让你彻底搞懂Websocket原理 http://blog.csdn.net/frank_good/article/details/50856585webSocket中并发的策略 http://blog.csdn.net/heshuangyuan123/article/details/39023569tcp socket文件句柄泄漏http://mdba.cn/2015/03/10/tcp-socket文件句柄泄漏/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot学习收获]]></title>
    <url>%2F2017%2F10%2F26%2Fspringboot%2F</url>
    <content type="text"><![CDATA[自己一些总结 修改网站小图标1、在application.properties中配：spring.mvc.favicon.enabled = false2、网站图片命名为favicon.ico;3、将favicon.ico放在resources/static目录下；4、ok，结束ヾ(◍°∇°◍)ﾉﾞ 启动彩蛋springboot项目启动总会打印一下内容，想要更换怎么办？1234567. ____ _ __ _ _/\\ / ___&apos;_ __ _ _(_)_ __ __ _ \ \ \ \( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \\\/ ___)| |_)| | | | | || (_| | ) ) ) )&apos; |____| .__|_| |_|_| |_\__, | / / / /=========|_|==============|___/=/_/_/_/:: Spring Boot :: (v1.4.0.RELEASE) 1、在resource目录下面放入一个banner.txt文件，Spring Boot启动项目的时候就会优先启动这个文件中的内容；2、在里面存放要打印的内容；3、文件中：Spring Boot提供了一个枚举类AnsiColor，通过${AnsiColor.BRIGHT_YELLOW}来控制文件中字符的颜色，${spring-boot.version}这个是springboot的版本号；4、ok啦啦啦…… 额外1234$&#123;application.version&#125; 这个是MANIFEST.MF文件中的版本号 $&#123;application.formatted-version&#125; 这个是上面的的版本号前面加v后上括号 $&#123;spring-boot.version&#125; 这个是springboot的版本号 $&#123;spring-boot.formatted-version&#125; 同上 统一异常处理404等错误123456789101112131415161718192021222324import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;import org.springframework.boot.web.servlet.ErrorPage;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.HttpStatus;@Configurationpublic class WebConfiguration &#123; @Bean public EmbeddedServletContainerCustomizer proEmbeddedServletContainerCustomizer() &#123; return new EmbeddedServletContainerCustomizer() &#123; @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; //如果是静态页面的异常处理，如404错误，此方式不能传递异常具体信息 //错误页面需要放在Spring Boot web应用的static内容目录下，它的默认位置是：src/main/resources/static， container.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND, &quot;/error/404.action&quot;)); container.addErrorPages(new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, &quot;/error/500.action&quot;)); &#125; &#125;; &#125;&#125; 123456789101112131415161718192021222324import org.springframework.http.HttpStatus;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseStatus;import javax.servlet.http.HttpServletRequest;@Controllerpublic class ErrorController &#123; @RequestMapping(value = &quot;/error/404.action&quot;) @ResponseStatus( HttpStatus.OK ) public String pageNotFound(HttpServletRequest req, HttpServletRequest response) &#123; req.setAttribute(&quot;errorMsg&quot;, &quot;哎呀，被外星人抓走了！&quot;); return &quot;error/error&quot;; &#125; @RequestMapping(value = &quot;/error/500.action&quot;) @ResponseStatus( HttpStatus.OK ) public String error(HttpServletRequest req, HttpServletRequest response) &#123; req.setAttribute(&quot;errorMsg&quot;, &quot;受伤啦啦啦！&quot;); return &quot;error/error&quot;; &#125;&#125; json统一异常处理1、参考：http://blog.didispace.com/springbootexception/2、在aop中对调用方法进行try catch，出现异常返回 邮件发送参考：http://blog.didispace.com/springbootmailsender/ 禁用依赖参考：http://blog.didispace.com/spring-boot-disable-autoconfig/ 接口参数校验Hibernate 的 Validator 做传入参数的校验。RestFul Api 接口参数校验及前后端交互校验 https://zhuanlan.zhihu.com/p/28399903 事务12345678@SpringBootApplication //等同于 @Configuration @EnableAutoConfiguration @ComponentScan@EnableTransactionManagement // 启注解事务管理，等同于xml配置方式的 &lt;tx:annotation-driven /&gt;@MapperScan(&quot;com.hfy.db.mapper&quot;)public class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; jar和dllmaven安装本地jarmaven安装本地jarmvn install:install-file -Dfile=C:/Users/hfy/Desktop/sigar-1.6.5.132.jar -DgroupId=org.hyperic -DartifactId=sigar -Dversion=1.6.5.132 -Dpackaging=jar Spring Boot引用本地jar包springboot加载dll 插件1、spring-boot-devtoolsmaven工程使用spring-boot-devtools进行热部署，更改代码避免重启web容器 多数据源springboot + mybatis + 多数据源 http://www.cnblogs.com/java-zhao/p/5413845.html 后台配置windowswindows平台下，jar包开机自启动好配置，可会有命令行窗口运行在界面上，容易不小心关闭。1、wrapper可以实现2、使用AlwaysUp软件 linux看文章：linux相关知识参考： http://blog.didispace.com/spring-boot-run-backend/ Wrapper配置详解及高级应用 参考参考链接：http://www.jianshu.com/p/692be2b00e6b]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot shiro权限控制]]></title>
    <url>%2F2017%2F10%2F26%2Fspringboot_shiro%2F</url>
    <content type="text"><![CDATA[用户权限 shiro简介Shiro是Apache下的一个开源项目，我们称之为Apache Shiro。它是一个很易用与Java项目的的安全框架，提供了认证、授权、加密、会话管理，与 Spring Security 一样都是做一个权限的安全框架，但是与Spring Security 相比，在于 Shiro 使用了比较简单易懂易于使用的授权方式。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot整合logback]]></title>
    <url>%2F2017%2F10%2F23%2Fspringboot-logback%2F</url>
    <content type="text"><![CDATA[整合logback，发送错误邮件 pom.xml中引入jar1234567891011&lt;!-- 发送邮件需要的2个jar --&gt;&lt;dependency&gt; &lt;groupId&gt;org.codehaus.janino&lt;/groupId&gt; &lt;artifactId&gt;janino&lt;/artifactId&gt; &lt;version&gt;2.7.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.mail&lt;/groupId&gt; &lt;artifactId&gt;mail&lt;/artifactId&gt; &lt;version&gt;1.4.7&lt;/version&gt;&lt;/dependency&gt; 配置logback1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--scan: 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。（这个功能可以在不重启运行环境下，调整打印日志的细节，方便定位问题）scanPeriod: 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。debug: 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。--&gt;&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt; &lt;!-- logger：日志所处的包 level：日志打印级别 --&gt; &lt;!--&lt;logger name=&quot;org.springframework&quot; level=&quot;WARN&quot; /&gt;--&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;property name=&quot;log.path&quot; value=&quot;./&quot; /&gt; &lt;property name=&quot;project.name&quot; value=&quot;springboot_logback&quot; /&gt; &lt;property name=&quot;smtpHost&quot; value=&quot;smtp.163.com&quot; /&gt; &lt;!--&lt;property name=&quot;smtpPort&quot; value=&quot;25&quot; /&gt;--&gt; &lt;property name=&quot;username&quot; value=&quot;xxx@163.com&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;xxx&quot; /&gt; &lt;property name=&quot;SSL&quot; value=&quot;false&quot; /&gt; &lt;property name=&quot;email_to&quot; value=&quot;xxx@qq.com&quot; /&gt; &lt;property name=&quot;email_from&quot; value=&quot;xxx@163.com&quot; /&gt; &lt;property name=&quot;email_subject&quot; value=&quot;【Error】: %logger&quot; /&gt; &lt;!--输出到控制台--&gt; &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;:%4p %t %F:%L - %m%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--文件输出的格式设置 --&gt; &lt;appender name=&quot;file&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;file&gt;$&#123;log.path&#125;/$&#123;project.name&#125;.log&lt;/file&gt; &lt;!-- 文件输出的日志 的格式 --&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;:%4p %t %F:%L - %m%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集，防止中文乱码 --&gt; &lt;/encoder&gt; &lt;!-- 配置日志所生成的目录以及生成文件名的规则 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/%d&#123;yyyy-MM&#125;/$&#123;project.name&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&lt;/fileNamePattern&gt; &lt;!--&lt;fileNamePattern&gt;%d&#123;yyyy-MM-dd&#125;.%i.log.zip&lt;/fileNamePattern&gt;--&gt; &lt;!-- 如果按天来回滚，则最大保存时间为365天，365天之前的都将被清理掉 --&gt; &lt;maxHistory&gt;365&lt;/maxHistory&gt; &lt;!-- 日志总保存量为1GB --&gt; &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;!--文件达到 最大30KB时会被压缩和切割 --&gt; &lt;maxFileSize&gt;30KB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;appender name=&quot;EMAIL&quot; class=&quot;ch.qos.logback.classic.net.SMTPAppender&quot;&gt; &lt;smtpHost&gt;$&#123;smtpHost&#125;&lt;/smtpHost&gt; &lt;smtpPort&gt;$&#123;smtpPort&#125;&lt;/smtpPort&gt; &lt;username&gt;$&#123;username&#125;&lt;/username&gt; &lt;password&gt;$&#123;password&#125;&lt;/password&gt; &lt;SSL&gt;$&#123;SSL&#125;&lt;/SSL&gt; &lt;asynchronousSending&gt;false&lt;/asynchronousSending&gt; &lt;to&gt;$&#123;email_to&#125;&lt;/to&gt; &lt;from&gt;$&#123;email_from&#125;&lt;/from&gt; &lt;subject&gt;$&#123;email_subject&#125;&lt;/subject&gt; &lt;layout class=&quot;ch.qos.logback.classic.html.HTMLLayout&quot; &gt; &lt;pattern&gt;%date%level%thread%logger&#123;0&#125;%line%message&lt;/pattern&gt; &lt;/layout&gt; &lt;filter class=&quot;ch.qos.logback.core.filter.EvaluatorFilter&quot;&gt; &lt;evaluator class=&quot;ch.qos.logback.classic.boolex.JaninoEventEvaluator&quot;&gt; &lt;expression&gt; if(level &gt; WARN) &#123; return true; &#125; return false; &lt;/expression&gt; &lt;/evaluator&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;root level=&quot;debug&quot;&gt; &lt;appender-ref ref=&quot;console&quot; /&gt; &lt;appender-ref ref=&quot;file&quot; /&gt; &lt;appender-ref ref=&quot;EMAIL&quot;/&gt; &lt;/root&gt;&lt;/configuration&gt; 使用123import org.slf4j.Logger;import org.slf4j.LoggerFactory;private Logger logger = LoggerFactory.getLogger(this.getClass()); 注意日期格式问题日期是 HH:mm:ss.SSS，而不是HH:mm:ss,SSSHH:mm:ss.SSS 是15:21:21.222HH:mm:ss,SSS 是07:21:21 error打印堆栈信息123logger.error(&quot;error: &#123;&#125;&quot;, e); //打印出堆栈信息logger.error(&quot;error: &#123;&#125;&quot;, e.getMessage());// 不打印出堆栈信息logger.error(&quot;删除用户(&#123;&#125;)异常：&#123;&#125;&quot;, id, e); // 不打印出堆栈信息]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FindBugs常见错误描述和解决方法]]></title>
    <url>%2F2017%2F10%2F18%2Ffindbugs%2F</url>
    <content type="text"><![CDATA[FindBugs常见错误描述和解决方法 本文转载自：http://blog.sina.com.cn/s/blog_4adc4b090102vi9p.html DLS_DEAD_LOCAL_STORE 描述： Dead store to 未使用的局部变量 解决方法：局部变量定义后未使用；实例化对象后又重新对该对象赋值 ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD 描述：Write to static field 通过实例方法更新静态属性 常见于常量类，直接通过类名.常量名获取的方式违背了封装的原则，findbugs不提倡使用，而如果将常量改成静态成员变量，又因为spring不支持静态注入导致不能实现，解决方法是非静态的setter调用静态的setter方法给静态成员变量赋值。 解决方法： 常量类F： 123 class F&#123; public static String a = “123”;&#125; 常量a改为静态成员变量，通过F.getA()获取，且由于spring不支持静态注入，改为：123456789101112class F&#123; private static String a; public static Integer getA() &#123; return a; &#125; public void setA(String a) &#123; setAValue(a); &#125; public static void setAValue(String a) &#123; F.a = a; &#125;&#125; BX_UNBOXING_IMMEDIATELY_REBOXED 描述： Boxed value is unboxed and then immediately reboxed 装箱的值被拆箱，然后立刻重新装箱了 常见的是三目运算时，同时存在基本类型和包装类型。 解决方法：123Integer a = null;//...a = (a == null)?0:a; 此问题在于a不为null时，会被拆箱，赋值时再装箱。这是自动装箱拆箱的特性，只要运算中有不同类型，当涉及到类型转换时，编译器就会向下转型，再进行运算。修改方法，统一类型：123Integer a = null;//...a = (a == null)?Integer.valueOf(0):a; SE_BAD_FIELD 描述： Non-transient non-serializable instance field in serializable class在可序列化的类中存在不能序列化或者不能暂存的数据 解决方法： 方法1：序列化该对象 方法2：当采用struts2框架开发，不可避免的此问题会大量出现，因为ActionSupport实现了序列化接口，action继承了此类，而service没序列化，所以在action中引用service对象时提示此错误，最简单的解决方法是将service对象声明成transient，即service不需要序列化 方法3(未验证)：To avoid java serialization you need to implement writeObject() and readObject() method in your Class and need to throw NotSerializableException from those method.（action中实现这两个方法?）123456private void writeObject(java.io.ObjectOutputStream stream) throws java.io.IOException &#123; throw new java.io.NotSerializableException( getClass().getName() );&#125;private void readObject(java.io.ObjectInputStream stream) throws java.io.IOException, ClassNotFoundException &#123; throw new java.io.NotSerializableException( getClass().getName() );&#125; NP_LOAD_OF_KNOWN_NULL_VALUE 描述： Load of known null value加载已知是null的值 解决方法：已知方法参数为null是，直接传递null而不是参数名 REC_CATCH_EXCEPTION 描述： Exception is caught when Exception is not thrown 过泛地捕获异常或捕获异常后未做任何处理 解决方法：异常分类捕获（至少要打印出此异常对象） NP_NULL_PARAM_DEREF 描述： Null passed for nonnull parameter 把空值传给了非空的参数 解决方法：增加非空判断 NP_IMMEDIATE_DEREFERENCE_OF_READLINE 描述： Immediate dereference of the result of readLine() 立即引用了readLine()的结果 解决方法：判断readLine的结果是否为空 EI_EXPOSE_REP 恶意代码漏洞 描述：may expose internal representation by returning getter方法返回引用类型 eclipse自动生成的引用类型(Object、数组、Date等)的getter、setter方法会得到或通过对可变对象的引用操作而暴露代码内部实现，解决方法很多，只要返回的或赋值的对象不是原引用对象即可。 解决方法：1234567//以Date类型为例：public Date getHappenTime() &#123;if(happenTime != null)&#123;return (Date) happenTime.clone();&#125; return null;&#125; EI_EXPOSE_REP2 恶意代码漏洞 描述：may expose internal representation by storing an externally mutable object into setter方法返回引用类型 eclipse自动生成的引用类型(Object、数组、Date等)的getter、setter方法会得到或通过对可变对象的引用操作而暴露代码内部实现，解决方法很多，只要返回的或赋值的对象不是原引用对象即可。 解决方法：12345678//以Date类型为例：public void setHappenTime(Date happenTime) &#123; if(happenTime != null)&#123; this.happenTime = (Date) happenTime.clone(); &#125;else&#123; this.happenTime = null; &#125;&#125;]]></content>
      <categories>
        <category>exception</category>
      </categories>
      <tags>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解负载均衡 会话保持 session同步(转)]]></title>
    <url>%2F2017%2F10%2F16%2Fjava_nginx%2F</url>
    <content type="text"><![CDATA[自己一些总结 转自：http://bbs.linuxtone.org/forum.php?mod=viewthread&amp;tid=18212 什么负载均衡 一个新网站是不要做负载均衡的，因为访问量不大，流量也不大，所以没有必要搞这些东西。但是随着网站访问量和流量的快速增长，单台服务器受自身硬件条件的限制，很难承受这么大的访问量。 在这种情况下，有二种方案可以选择： 1，对单台服务器的硬件进行更新，由双核的变成四核的，内存加大等。 2，增加服务器的台数，来分担服务器的负担。以实现增加网络带宽，增加服务器的处理能力的目的。 第一种方法可以理解为纵向发展，这种方法总是有限。 第二种方法才是解决问题的正确选择。 实现负载均衡的方法，大至分为二个方向，一种是用软件来实现负载均衡，另一种是硬件实现负载均衡（包括结合硬件和软件）用软件来实现负载均衡，实现负载均衡的过程，自身也要消耗一些系统资源，响应时间增加。例如：LVS,nginx,haproxy,apache等这些基于应用层的负载均衡软件，适合那些访问量不是特别大的网站。如果像sina,163这样大访量的网站，用硬件来实现负载均衡是最明志的选择。 负载均衡的算法很多，有根据请求数来进行负载均衡的，有根IP来负载均衡的，有根据流量的等等。我经常会用的二种算法: 1、根据请求数 a，可以实现各台服务器都能比较平均分担客户的请求，其中一台服务器down掉的话也不会造成不好的影响。 b，服务器间的状态要同步，如session，需要其他手段来同步这些状态。 2、根据IP a，ip_hash算法可以把一个ip映射到一台服务器上，这样可以解决session同步的问题 b，ip_hash也有不好的地方就是，假如其中的一台服务器down掉的话，映射到这台的服务器的用户就郁闷了。 c，ip_hash容易导致负载不均衡的情况，现在河蟹政府对google的搜索关键词进行过滤，你会经常发现google打不开，但是过一会就好了。这让那些google的爱好者们郁闷不已，很多用户都到国外找代理去了，狗急跳墙，人急帆樯。如果这样的话，这些代理会被分到同一个服务器，会导致负载不均衡 ，甚至失效。 什么是会话保持，有什么作用 会话保持是指在负载均衡器上有一种机制，在作负载均衡的同时，还保证同一用户相关连的访问请求会被分配到同一台服务器上。 会话保持有什么作用呢，举例说明一下 如果有一个用户访问请求被分配到服务器A，并且在服务器A登录了，并且在很短的时间，这个用户又发出了一个请求，如果没有会话保持功能的话，这个用户的请求很有可能会被分配到服务器B去，这个时候在服务器B上是没有登录的，所以你要重新登录，但是用户并不知道自己的请求被分配到了哪里，用户的感觉就是登录了，怎么又要登录，用户体验很不好。 还有你在淘宝上面买东西，从登录＝》拍得东西＝》添加地址＝》付款，这是一个一系列的过程，也可以理解成一次操作过程，所有这一系列的操作过程都应当由一台服务器完成，而不能被负载均衡器分配到不同的服务器上。 会话保持都会有时间的限制（映射到固定某一台的服务器除外，如：ip_hash）,各种负载均衡工具都会提供这种会话保持时间的设置，LVS，apache等。连php语言都提供了会话保持时间的设定session.gc_maxlifetime会话保持时间的设定要大于session生存时间的设定，这样可以减少需要同步session的情况，但是不能杜绝。所以同步session还是要做的。 session同步 为什么要进行session同步，说会话保持的时候已经提到了。具体方法请参考web集群时session同步的3种方法 web集群时session同步的3种方法 在做了web集群后，你肯定会首先考虑session同步问题，因为通过负载均衡后，同一个IP访问同一个页面会被分配到不同的服务器上，如果session不同步的话，一个登录用户，一会是登录状态，一会又不是登录状态。所以本文就根据这种情况给出三种不同的方法来解决这个问题： 利用数据库同步session 在做多服务器session同步时我没有用这种方法，如果非要用这种方法的话，我想过二种方法： a，用一个低端电脑建个数据库专门存放web服务器的session，或者，把这个专门的数据库建在文件服务器上，用户访问web服务器时，会去这个专门的数据库check一下session的情况，以达到session同步的目的。 b，这种方法是把存放session的表和其他数据库表放在一起，如果mysql也做了集群了话，每个mysql节点都要有这张表，并且这张session表的数据表要实时同步。 说明：用数据库来同步session，会加大数据库的负担，数据库本来就是容易产生瓶颈的地方，如果把session还放到数据库里面，无疑是雪上加霜。上面的二种方法，第一点方法较好，把放session的表独立开来，减轻了真正数据库的负担 利用cookie同步session session是文件的形势存放在服务器端的，cookie是文件的形势存在客户端的，怎么实现同步呢？方法很简单，就是把用户访问页面产生的session放到cookie里面，就是以cookie为中转站。你访问web服务器A，产生了session把它放到cookie里面了，你访问被分配到web服务器B，这个时候，web服务器B先判断服务器有没有这个session，如果没有，在去看看客户端的cookie里面有没有这个session，如果也没有，说明session真的不存，如果cookie里面有，就把cookie里面的sessoin同步到web服务器B，这样就可以实现session的同步了。 说明：这种方法实现起来简单，方便，也不会加大数据库的负担，但是如果客户端把cookie禁掉了的话，那么session就无从同步了，这样会给网站带来损失；cookie的安全性不高，虽然它已经加了密，但是还是可以伪造的。 利用memcache同步session memcache可以做分布式，如果没有这功能，他也不能用来做session同步。他可以把web服务器中的内存组合起来，成为一个”内存池”，不管是哪个服务器产生的sessoin都可以放到这个”内存池”中，其他的都可以使用。 优点：以这种方式来同步session，不会加大数据库的负担，并且安全性比用cookie大大的提高，把session放到内存里面，比从文件中读取要快很多。 缺点：memcache把内存分成很多种规格的存储块，有块就有大小，这种方式也就决定了，memcache不能完全利用内存，会产生内存碎片，如果存储块不足，还会产生内存溢出。 总结 上面三种方法都是可行的 第一种方法，最影响系统速度的那种，不推荐使用； 第二种方法，效果不错，不过安全隐患一样的存在； 第三种方法，个人觉得第三种方法是最好的，推荐大家使用;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的HashMap]]></title>
    <url>%2F2017%2F10%2F16%2Fjava-HashMap%2F</url>
    <content type="text"><![CDATA[hashMap的那些事 参考深入分析ConcurrentHashMap]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[adminLTE使用中遇到的难点]]></title>
    <url>%2F2017%2F09%2F05%2Fadminlte%2F</url>
    <content type="text"><![CDATA[这里主要记录使用adminlte时遇到的困难。 修改form缩放展开图标1234567891011121314151617181920212223&lt;script&gt; // 在引入js之前更改配置 var AdminLTEOptions = &#123; boxWidgetOptions: &#123; boxWidgetIcons: &#123; //Collapse icon collapse: &apos;fa-angle-down&apos;, //Open icon open: &apos;fa-angle-right&apos;, //Remove icon remove: &apos;fa-times&apos; &#125;, boxWidgetSelectors: &#123; //Remove button selector remove: &apos;[data-widget=&quot;remove&quot;]&apos;, //Collapse button selector collapse: &apos;[data-widget=&quot;collapse&quot;]&apos; &#125; &#125; &#125;;&lt;/script&gt;&lt;script src=&quot;&lt;%=basePath%&gt;/adminlte/dist/js/app.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&lt;%=basePath%&gt;/adminlte/dist/js/app.min.js&quot;&gt;&lt;/script&gt; 结合chart.js，显示图标，导出图片chart.js 不提供任何方法来导出成图片格式。但是因为 chart.js 使用 Canvas 画布来构建图表，因此可以使用 Canvas 画布的功能来输出图表到图片。12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;a id=&quot;link1&quot; download=&quot;CHARTJS.jpg&quot; class=&quot;btn btn-default btn-xs&quot;&gt;&lt;i class=&quot;fa fa-share-square-o &quot;&gt;&lt;/i&gt;&amp;nbsp;导出&lt;/a&gt;&lt;div class=&quot;chart&quot;&gt; &lt;canvas id=&quot;lineChart&quot; style=&quot;height:250px&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; $(function () &#123; var lineChartData = &#123; labels: $&#123;hours&#125;, datasets: [ &#123; label: &quot;test1&quot;, fillColor: &quot;rgba(210, 214, 222, 1)&quot;, strokeColor: &quot;rgba(210, 214, 222, 1)&quot;, pointColor: &quot;rgba(210, 214, 222, 1)&quot;, pointStrokeColor: &quot;#c1c7d1&quot;, pointHighlightFill: &quot;#fff&quot;, pointHighlightStroke: &quot;rgba(220,220,220,1)&quot;, data: $&#123;inCarNums&#125; &#125; ] &#125;; var lineChartOptions = &#123; // 省略一些配置 onAnimationComplete: done // calls function done() &#123;&#125; at end 重点 &#125;; //------------- //- LINE CHART - //-------------- var lineChartCanvas = $(&quot;#lineChart&quot;).get(0).getContext(&quot;2d&quot;); var lineChart = new Chart(lineChartCanvas); lineChart.Line(lineChartData, lineChartOptions); &#125;); function done()&#123; var url_base64jp = document.getElementById(&quot;lineChart&quot;).toDataURL(&quot;image/jpg&quot;); $(&quot;#link1&quot;).attr(&quot;href&quot;, url_base64jp); &#125;&lt;/script&gt; 参考Converting Chart.js canvas chart to image using .toDataUrl() results in blank image将 Chart.js 生成的图表导出成图片]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js一些其他问题]]></title>
    <url>%2F2017%2F08%2F25%2Fjs%2F</url>
    <content type="text"><![CDATA[记录网上一些好的解决办法的链接 扫描一个二维码扫描一个二维码，android和ios都可以下载app。其中涉及到的点：1、html中要判断是来自android还是ios2、因为一般人使用微信扫一扫，所以，判断若是微信，提示在浏览器中打开。 判断打开来源（浏览器 || IOS || Android）1234567891011121314151617181920212223242526272829var browser = &#123; versions: function() &#123; var u = navigator.userAgent, app = navigator.appVersion; var isWeixin = !!/MicroMessenger/i.test(u); return &#123;//移动终端浏览器版本信息 trident: u.indexOf(&apos;Trident&apos;) &gt; -1, //IE内核 presto: u.indexOf(&apos;Presto&apos;) &gt; -1, //opera内核 webKit: u.indexOf(&apos;AppleWebKit&apos;) &gt; -1, //苹果、谷歌内核 gecko: u.indexOf(&apos;Gecko&apos;) &gt; -1 &amp;&amp; u.indexOf(&apos;KHTML&apos;) == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/) || !!u.match(/AppleWebKit/), //是否为移动终端 ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1, //android终端或者uc浏览器 iPhone: u.indexOf(&apos;iPhone&apos;) &gt; -1 || u.indexOf(&apos;Mac&apos;) &gt; -1, //是否为iPhone或者QQHD浏览器 iPad: u.indexOf(&apos;iPad&apos;) &gt; -1, //是否iPad webApp: u.indexOf(&apos;Safari&apos;) == -1 //是否web应该程序，没有头部与底部 &#125;; &#125;(), language: (navigator.browserLanguage || navigator.language).toLowerCase()&#125;if (browser.versions.ios || browser.versions.iPhone || browser.versions.iPad) &#123; // ios window.location = &quot;http://...&quot;;&#125;else if (browser.versions.android) &#123; // android // todo: Check if it opens in WeChat, if yes, remind, otherwise jump directly to the download link&#125; 判断打开来源(微信 || 支付宝)12345678910111213141516function isWechat()&#123; var ua = window.navigator.userAgent.toLowerCase(); if(ua.match(/MicroMessenger/i) == &apos;micromessenger&apos;)&#123; return true; &#125;else&#123; return false; &#125;&#125;function isAli()&#123; var ua = window.navigator.userAgent.toLowerCase(); if(ua.match(/AlipayClient/i) ==&apos;alipayclient&apos;)&#123; return true; &#125;else&#123; return false; &#125;&#125; 参考以下是一些好的文章１、JS怎么刷新当前页面2、jQuery中$.click()无效问题分析3、HTML5服务器推送消息的各种解决办法]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[objectMapper中自定义类型转换]]></title>
    <url>%2F2017%2F06%2F30%2Fjava-objectMapper%2F</url>
    <content type="text"><![CDATA[自己一些总结 日期类型转换使用mapper.setDateFormat();来设置日期转换12@Select(&quot;select * from $&#123;tableName&#125;&quot;)List&lt;Map&lt;String, Object&gt;&gt; getTableData(@Param(&quot;tableName&quot;) String tableName); 12345678910List&lt;Map&lt;String, Object&gt;&gt; tableDatas = tableDataMapper.getTableData(&quot;user&quot;);for (Map&lt;String, Object&gt; tableData: tableDatas) &#123; ObjectMapper mapper = new ObjectMapper(); String data = mapper.writeValueAsString(tableData); System.out.println(data); mapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;)); data = mapper.writeValueAsString(tableData); System.out.println(data); System.out.println(&quot;=============&quot;);&#125; 对于byte的处理1234567891011121314151617181920212223public static ObjectMapper getObjectMapperForUplink() &#123; ObjectMapper mapper = new ObjectMapper();// mapper.configure(SerializationFeature.INDENT_OUTPUT, true); mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false); mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); // 处理字节 SimpleModule simpleModule = new SimpleModule(); simpleModule.addSerializer(byte[].class, getByteSerialize()); mapper.registerModule(simpleModule); // 处理日期 mapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;)); return mapper;&#125;private static JsonSerializer&lt;byte[]&gt; getByteSerialize() &#123; return new JsonSerializer&lt;byte[]&gt;() &#123; @Override public void serialize(byte[] value, JsonGenerator gen, SerializerProvider serializers) throws IOException, JsonProcessingException &#123; gen.writeString(&quot;&quot;); // 此处可实现字节转成字符串。如压缩等 &#125; &#125;;&#125; 参考jackson中自定义处理序列化和反序列化 http://jackyrong.iteye.com/blog/2005323]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot中的过滤器]]></title>
    <url>%2F2017%2F06%2F02%2Fspringboot-filter%2F</url>
    <content type="text"><![CDATA[做api项目，各个接口都有对应的权限。所以使用过滤器对各个请求进行过滤。以下是学习的简单总结。 springboot中使用filter 在springboot项目中使用filter，需要注入bean：123456789101112131415161718@SpringBootApplication //等同于 @Configuration @EnableAutoConfiguration @ComponentScanpublic class SpringbootFilterDemoApp &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootFilterDemoApp.class, args); &#125; @Bean public FilterRegistrationBean filterRegistrationBean() &#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new AuthorizationFilter()); // 自己的filter List&lt;String&gt; urlPatterns = new ArrayList&lt;&gt;(); urlPatterns.add(&quot;/openapi/*&quot;); registrationBean.setUrlPatterns(urlPatterns); return registrationBean; &#125;&#125; 过滤器filter 以下是自己的filter类。继承Filter接口，对于满足条件的请求，使用filterChain.doFilter(request, response);将连接转发到目的地，不满足，则直接通过response写入错误信息。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 过滤器：校验接口访问权限 */public class AuthorizationFilter implements Filter&#123; private static final Logger logger = LoggerFactory.getLogger(AuthorizationFilter.class); private CheckAuth checkAuth; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; // 将请求转换成HttpServletRequest 请求 HttpServletRequest req = (HttpServletRequest) servletRequest; HttpServletResponse rsp = (HttpServletResponse) servletResponse; // 取得接口URI String currentURI = req.getRequestURI(); // 注入checkAuth对象 。。。 // 读取请求参数 。。。 if (requestWrapper == null) &#123; strError = &quot;请求方式错误！&quot;; &#125; else &#123; if (&quot;&quot;.equals(accessToken)) &#123; strError = &quot;缺少必要的参数&quot;; &#125; else &#123; // 校验接口权限 if (checkAuth.checkAuth(accessToken, currentURI)) &#123; // Filter 只是链式处理，请求依然转发到目的地址。 filterChain.doFilter(requestWrapper, rsp); return; &#125; else &#123; strError = &quot;权限不足&quot;; &#125; &#125; &#125; rsp.setCharacterEncoding(&quot;UTF-8&quot;); rsp.setContentType(&quot;application/json; charset=utf-8&quot;); String rspValue = &quot;&quot;; // 返回错误json信息 logger.info(&quot;返回：&#123;&#125;&quot;, rspValue); rsp.getWriter().write(rspValue); &#125; @Override public void destroy() &#123; &#125;&#125; 注意事项 filter中注入对象 filter的加载在servlet之前。所以在Filter中使用@Autowired注入对象CheckAuth肯定会失败。我们可以使用WebApplicationContextUtils来获取对象。(可参考：web.xml 中的listener、 filter、servlet 加载顺序及其详解)123456// 注入checkAuth对象ServletContext sc = req.getSession().getServletContext();WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(sc);if (context != null &amp;&amp; context.getBean(&quot;checkAuth&quot;) != null &amp;&amp; checkAuth == null) &#123; checkAuth = context.getBean(CheckAuth.class);&#125; 流的读取 读取请求参数：对于post请求，我们通过stream流进行读取，但是会发现，直接读取response流中的数据后，使用filterChain.doFilter(requestWrapper, rsp);请求，会报错：没有请求内容。 因为： stream流的意思就是说当你读取之后就无法回到上一次读取的数据。所以说流是单向的。当第一个filter中读取流之后流已经被读完。所以无法继续读取。所以第二个filter中读不到数据。 为了防止流读取一次后就没有了, 所以需要将流继续写出去。 下面是对Request的封装。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.io.BufferedReader;import java.io.ByteArrayInputStream; import java.io.IOException; import java.io.InputStreamReader; import java.nio.charset.Charset; import java.util.Enumeration; import javax.servlet.ReadListener;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;/** * httpServletRequst封装类 */public class HttpServletRequestWrapper extends javax.servlet.http.HttpServletRequestWrapper &#123; private final byte[] body; public HttpServletRequestWrapper(HttpServletRequest request) throws IOException &#123; super(request); body = HttpHelper.getBodyString(request).getBytes(Charset.forName(&quot;UTF-8&quot;)); &#125; @Override public BufferedReader getReader() throws IOException &#123; return new BufferedReader(new InputStreamReader(getInputStream())); &#125; @Override public ServletInputStream getInputStream() throws IOException &#123; final ByteArrayInputStream bais = new ByteArrayInputStream(body); return new ServletInputStream() &#123; @Override public boolean isFinished() &#123; return false; &#125; @Override public boolean isReady() &#123; return false; &#125; @Override public void setReadListener(ReadListener listener) &#123; &#125; @Override public int read() throws IOException &#123; return bais.read(); &#125; &#125;; &#125; @Override public String getHeader(String name) &#123; return super.getHeader(name); &#125; @Override public Enumeration&lt;String&gt; getHeaderNames() &#123; return super.getHeaderNames(); &#125; @Override public Enumeration&lt;String&gt; getHeaders(String name) &#123; return super.getHeaders(name); &#125;&#125; request读取数据工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.BufferedReader;import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.nio.charset.Charset; import javax.servlet.ServletRequest; public class HttpHelper &#123; /** * 获取请求Body * * @param request * @return */ public static String getBodyString(ServletRequest request) &#123; StringBuilder sb = new StringBuilder(); InputStream inputStream = null; BufferedReader reader = null; try &#123; inputStream = request.getInputStream(); reader = new BufferedReader(new InputStreamReader(inputStream, Charset.forName(&quot;UTF-8&quot;))); String line; while ((line = reader.readLine()) != null) &#123; sb.append(line); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (inputStream != null) &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return sb.toString(); &#125; &#125; 获取请求参数get、post获取请求参数的方式是不一样的。1234567891011121314if (req.getMethod().equals(&quot;POST&quot;)) &#123; requestWrapper = new HttpServletRequestWrapper(req); String reqParamsStr = HttpHelper.getBodyString(requestWrapper); if(reqParamsStr.length() &gt;0) &#123; // 从json字符串获取参数 accessToken = &quot;&quot;; &#125;&#125; else if (req.getMethod().equals(&quot;GET&quot;)) &#123; requestWrapper = req; String[] tokens = req.getParameterValues(&quot;accessToken&quot;); if (tokens != null &amp;&amp; tokens.length &gt; 0) &#123; accessToken = tokens[0]; &#125;&#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页转图片]]></title>
    <url>%2F2017%2F06%2F02%2Fjava-html-img%2F</url>
    <content type="text"><![CDATA[一些总结 html2image示例代码如下：123456HtmlImageGenerator imageGenerator = new HtmlImageGenerator();String htmlstr = &quot;&lt;div&gt;xxxxxxxxx&lt;/div&gt;&quot;;imageGenerator.loadHtml(htmlstr);imageGenerator.getBufferedImage();imageGenerator.saveAsImage(&quot;d:/hello-world.png&quot;);imageGenerator.saveAsHtmlWithMap(&quot;hello-world.html&quot;, &quot;hello-world.png&quot;); maven:12345&lt;dependency&gt; &lt;groupId&gt;com.github.xuwei-k&lt;/groupId&gt; &lt;artifactId&gt;html2image&lt;/artifactId&gt; &lt;version&gt;0.1.0&lt;/version&gt;&lt;/dependency&gt; 放弃的原因：1、css样式不能写在&lt;style&gt;标签中，不能引用其他css文件，只能写在style属性中。2、对css的支持不好。 cssbox官网：http://cssbox.sourceforge.net/示例代码如下：123456ImageRenderer render = new ImageRenderer();String url = &quot;&quot;;FileOutputStream out = new FileOutputStream(new File(filePath));render.setWindowSize(new Dimension(1080,1920), false);render.renderURL(url, out, ImageRenderer.Type.PNG);out.close(); maven:12345 &lt;dependency&gt; &lt;groupId&gt;net.sf.cssbox&lt;/groupId&gt; &lt;artifactId&gt;cssbox&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; 优点：调用非常简单，能支持较多的css。 遇到的问题1、部署到测试linux系统，正常，部署到线上linux系统，发现导出的图片中文文字全部不显示。原因：不支持中文字体。（安装字体请看：linux相关知识）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList的线程安全问题]]></title>
    <url>%2F2017%2F06%2F02%2Fjava-thread-arraylist%2F</url>
    <content type="text"><![CDATA[ArrayList是不安全的。多个线程对ArrayList操作，会出现问题。 实例1 下面这个demo，主要测试内容：三个线程，一个线程向集合中add数据，一个线程从集合中remove数据，一个线程判断如果集合中有数据，从其中获取数据。运行程序，会报错：越界异常。 以下是异常图片：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.ArrayList;import java.util.Collections;import java.util.List;public class ArrayListThreadTest &#123;// private static List&lt;String&gt; TEST_LIST = new CopyOnWriteArrayList&lt;String&gt;(); private static List&lt;String&gt; TEST_LIST = Collections.synchronizedList(new ArrayList&lt;String&gt;());// private static List&lt;String&gt; TEST_LIST = new ArrayList&lt;&gt;(); public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; TEST_LIST.add(&quot;11&quot;); System.out.println(&quot;Thread1 running&quot;); &#125; &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; TEST_LIST.clear(); System.out.println(&quot;Thread2 running&quot;); &#125; &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (TEST_LIST.size() &gt; 0) &#123; int size = TEST_LIST.size(); System.out.println(size + &quot;====&quot;); System.out.println(size + &quot;===&quot; + TEST_LIST.get(size-1)); &#125;// System.out.println(&quot;Thread3 running&quot;); &#125; &#125; &#125;).start(); &#125;&#125; 实例2 演示内容：多个线程向集合arraylist、线程安全的arraylist中添加数据，集合长度不同。 下面例子则来源于：http://www.oschina.net/code/snippet_70229_242512345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Random;// Java语言: ArrayList的线程安全与不安全对比演示public class ThreadSafeDemo &#123; public static int demo(final List list, final int testCount) throws InterruptedException &#123; ThreadGroup group = new ThreadGroup(list.getClass().getName() + &quot;@&quot; + list.hashCode()); final Random rand = new Random(); Runnable listAppender = new Runnable() &#123; public void run() &#123; try &#123; Thread.sleep(rand.nextInt(2)); &#125; catch (InterruptedException e) &#123; return; &#125; list.add(&quot;0&quot;); &#125; &#125;; for (int i = 0; i &lt; testCount; i++) &#123; new Thread(group, listAppender, &quot;InsertList-&quot; + i).start(); &#125; while (group.activeCount() &gt; 0) &#123; Thread.sleep(10); &#125; return list.size(); &#125; public static void main(String[] args) throws InterruptedException &#123; List unsafeList = new ArrayList(); List safeList = Collections.synchronizedList(new ArrayList()); final int N = 10000; for (int i = 0; i &lt; 10; i++) &#123; unsafeList.clear(); safeList.clear(); int unsafeSize = demo(unsafeList, N); int safeSize = demo(safeList, N); System.out.println(&quot;unsafe/safe: &quot; + unsafeSize + &quot;/&quot; + safeSize); &#125; &#125;&#125; 总结 ArrayList是线程不安全的，多线程中，我们可以使用Collections.synchronizedList(list);方法使其转换成安全的。或者我们也可以调用自己写的get、set、remove方法方法，自己方法内部加锁，调用list的get、set、remove方法1234567891011121314151617public class TestList &#123; public static List&lt;String&gt; list = new ArrayList&lt;&gt;(); public static void addMessage(String message)&#123; synchronized (TestList.class) &#123; list.add(message); &#125; &#125; public static void getMessage(String message)&#123; synchronized (TestList.class) &#123; if (list.size() &gt; 0) &#123; list.remove(0); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具类]]></title>
    <url>%2F2017%2F06%2F02%2Fjava-util%2F</url>
    <content type="text"><![CDATA[常用的工具类 date获取日期是星期几： 可以使用SimpleDateFormat：EEEE代表星期； 另外：MMMM代表中文月份 File下载文件并保存在服务器上时，最好使用当前操作系统的分隔符获取方法：private String sepa = java.io.File.separator;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax常见问题]]></title>
    <url>%2F2017%2F05%2F24%2Fajax%2F</url>
    <content type="text"><![CDATA[这里主要记录用ajax时遇到的问题。 获取ajax返回结果 ajax是异步的。通常我们在succee、error中获取到后台返回的数据。如果我们想在外面获取呢？这时就需要使用responseText了。1234567891011121314151617181920212223242526var rspTxt = $.ajax(&#123; async:false, cache:false, type : &quot;POST&quot;, url : &quot;&lt;%=basePath%&gt;test.action&quot;, data : &#123; id: $(&quot;#id&quot;).val() &#125;, success : function(data) &#123; var status = data.status; if(&apos;success&apos; == status)&#123; alert(&quot;成功！&quot;); &#125;else&#123; &#125; &#125;, error:function()&#123; alert(&quot;失败！&quot;); &#125;&#125;).responseText;if(typeof(rspTxt) != &quot;undefined&quot;) &#123; var obj = JSON.parse(rspTxt); if(obj.status == &apos;success&apos;) &#123; // 业务处理 &#125;&#125; access-origin ajax如果跨域请求，会报错。即：相同主机不同端口、不同主机的访问。此种问题我们需要在服务器端进行配置 以下是springmvc项目的处理方式：123456789101112131415public class SimpleCORSFilter implements Filter &#123; public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123; HttpServletResponse response = (HttpServletResponse) res; response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE&quot;); response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;); response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;x-requested-with&quot;); chain.doFilter(req, res); &#125; public void init(FilterConfig filterConfig) &#123;&#125; public void destroy() &#123;&#125;&#125; 以下是springboot项目的处理方式：12345678// 方式一@RestController@Api(&quot;测试ajax跨域&quot;)@RequestMapping(&quot;ajaxdemo&quot;)@CrossOriginpublic class TestHttpController &#123; // ...&#125; 123456789101112131415// 方式二import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.servlet.mvc.method.annotation.AbstractJsonpResponseBodyAdvice;/** * Created by Tony on 2017/8/1. * Spring Boot支持跨域请求的JSONP数据. */@ControllerAdvice(basePackages = &#123;&quot;com.cyf.uicomm&quot;&#125;)public class JSONPConfiguration extends AbstractJsonpResponseBodyAdvice &#123; public JSONPConfiguration() &#123; super(&quot;callback&quot;, &quot;jsonp&quot;); &#125;&#125; ajax请求页面刷新 ajax请求，发现页面闪烁以下，刷新。可以配置global: false来解决123456789101112$.ajax(&#123; global: false, type : &quot;POST&quot;, url : &quot;&quot;, data : &#123; &#125;, dataType : &quot;json&quot;, success : function(data) &#123; &#125;, error : function() &#123; &#125;&#125;); 参考：spring mvc 跨域请求处理——spring 4.2 以上玩转spring boot——ajax跨域]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2017%2F05%2F24%2Fgit%2F</url>
    <content type="text"><![CDATA[git常用命令 基本命令12345678910111213141516171819202122232425262728293031323334353637381、克隆代码 git clone 地址2、查看当前状态 git status 状态分为 &quot;未跟踪&quot; Untracked 未跟踪的文件需要git add 添加之后，执行commit才会保存到版本库中。 &quot;已经修改&quot; modified 执行commit才会保存到版本库中。 &quot;已经删除&quot; deleted 本地删除文件不代表版本库中已经删除，需要执行git rm [文件名]3、添加未跟踪文件 git add [文件名] 注意：不要git add . 这样会让eclipse生成的文件也add进去。 使用add * 使用 `git add *.java, *.jsp`4、提交代码 git commit [文件名] -m &quot;注释&quot; 5、从版本库拉代码 git pull6、代码提交到版本库 git push7、查看文件修改情况 git diff [文件名] 如果不加文件名，会将所有已经修改的文件与版本库进行比较8、回滚 git reset [--hard] [--mixed] [--hard] 是强制抹除修改，未提交的修改会丢失。 git reset --hard #######慎重使用##### [--mixed] 是保存修改，相当于重新提交。9、rebase git rebase [分支名] //一般基于origin/master rebase 即 git rebase origin/master 本次提交后，从版本库拉去代码，别人也修改了。此时两者不在一条线上，rebase合并。 出现冲突时， 1、查看那些文件冲突： git status 2、修改： 3、将冲突文件修改后添加：git add 文件名 4、git rebase --continue10、图形界面工具 gitk --all 修改撤回123git diff &gt; tmp.diff //修改内容暂存置tmp.diffgit reset --hard //去除修改rm -f tmp.diff //删除tmp.diff 分支12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849501、查看本地分支 git branch * dev master *代表当前位于dev分支2、查看远程分支 git branch -r origin/dev origin/master 3、查看本地和远程分支 git branch -a4、创建分支 git checkout -b new_branch 注意，new_branch的代码来自于当前分支5、切换分支 git checkout another_branch 和创建分支就差-b参数6、push本地分支代码到远端服务器 git push origin branch_name 如果远端服务器没有该分支，将会自动创建7、pull远端分支代码到本地对应分支 git pull origin branch_name 8、删除本地分支,首先切换到别的分支,然后才能删除某个分支 git checkout b git branch -d a 9、删除远程分支 git push origin --delete branch_name 10、合并本地分支b4.5到master上： git checkout master git merger b4.5 将本地的b4.5分支代码合并到当前分支master中 出现冲突: 1、修改冲突文件 2、git add 3、git commit11、合并远程分支，和前面的几乎一样， git merge origin/b 远程分支b被合并到本地当前分支dev中了。12、重命名分支： git branch -m &lt;old_name&gt; &lt;new_name&gt; (如果有同名会失败，改用 -M 可以强制覆盖) 标签12345678910111、查看本地标签： git tag2、推送所有标签： git push --tags3、删除本地标签： git tag -d 标签名4、删除远程标签： git push origin --delete tag 标签名 文件追踪问题123456如果我们不小心将某个文件加入了 git 版本控制，但是突然又不想继续跟踪控制这个文件了，怎么办呢？使用 git update-index 即可。不想继续追踪某个文件git update-index --assume-unchanged your_file_path如果想再次继续跟踪某个文件git update-index --no-assume-unchanged your_file_path windows gitk 乱码1234vi .gitconfig。 或者打开C:\Users\cage\.gitconfig文件在文件末尾加上：[gui] encoding = utf-8 某次提交合并到分支上12345678将分支b2上的某次提交合并到分支b1上。1、b2分支上：查看commit号 git log2、切换到b1分支 git checkout b1 git cherry-pick ef895d2b76610d9c41e901e09e4c483a132870e23、出现冲突，解决后使用 git cherry-pick --continue git绑定两个远程仓库http://www.cnblogs.com/beileixinqing/p/7493302.html]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea中配置tomcat]]></title>
    <url>%2F2017%2F05%2F21%2Fidea-tomcat%2F</url>
    <content type="text"><![CDATA[在idea中添加tomcat，运行springmvc项目。 配置tomcat简单配置，参考: IDEA中如何配置Tomcat和项目 注意事项以下是我的项目的配置：注意事项已在图中标出 其他问题intellij idea让资源文件自动更新 IDEA 单元测试 导入JUnit4到项目]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot与activemq]]></title>
    <url>%2F2017%2F05%2F18%2Fspringboot-activemq%2F</url>
    <content type="text"><![CDATA[本文章简单介绍了activemq，以及在springboot项目中使用activemq activemq介绍 ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。 ActiveMQ的消息机制： 1.点对点方式： 每个消息只能有一个消费者。 2.发布/订阅消息传递域 每个消息可以有多个消费者。 在springboot中使用配置pom文件12345&lt;!-- activemq --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件1234567891011spring: activemq: broker-url: tcp://localhost:61616 # URL of the ActiveMQ broker.Auto-generated by default. For instance `tcp://localhost:61616` in-memory: false # Specify if the default broker URL shouldbe in memory. Ignored if an explicit broker has been specified.是否是内存模式 password: x # Login password of the broker. user: xx # Login user of the broker. packages: trust-all: false trusted: com.hfy.activemq # Trust all packages. pool: enabled: false 配置工厂1234567891011121314151617181920212223242526272829303132333435import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.jms.annotation.EnableJms;import org.springframework.jms.config.DefaultJmsListenerContainerFactory;import org.springframework.jms.config.JmsListenerContainerFactory;import javax.jms.ConnectionFactory;@Configuration@EnableJmspublic class JmsConfiguration &#123; // queue模式的ListenerContainer @Bean(name = &quot;jmsListenerContainerQueue&quot;) public JmsListenerContainerFactory&lt;?&gt; jmsListenerContainerQueue(ConnectionFactory activeMQConnectionFactory) &#123; DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory(); // 实际运行时DefaultMessageListenerContainer对象将使用5000ms(5s)这个时间间隔刷新JMS连接，输出连接异常信息 // 此处使用10s重连 bean.setRecoveryInterval(10000L); bean.setConnectionFactory(activeMQConnectionFactory); return bean; &#125; // topic模式的ListenerContainer @Bean(name = &quot;jmsListenerContainerTopic&quot;) public JmsListenerContainerFactory&lt;?&gt; jmsListenerContainerTopic(ConnectionFactory activeMQConnectionFactory) &#123; DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory(); // 实际运行时DefaultMessageListenerContainer对象将使用5000ms(5s)这个时间间隔刷新JMS连接，输出连接异常信息 // 此处使用10s重连 bean.setRecoveryInterval(10000L); bean.setPubSubDomain(true); bean.setConnectionFactory(activeMQConnectionFactory); return bean; &#125;&#125; 发送消息1234567891011121314151617181920import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jms.core.JmsTemplate;import org.springframework.stereotype.Service;@Servicepublic class SendMsgServiceImpl implements SendMsgService &#123; private static final Logger logger = LoggerFactory.getLogger(SendMsgServiceImpl.class); @Autowired private JmsTemplate jmsTemplate; @Override public void sendQueueMessageText(String message) &#123; logger.info(&quot;activemq发送消息：&#123;&#125;&quot;, message); jmsTemplate.convertAndSend(QueueList.QUEUE_SEND, message); &#125;&#125; 接收消息 此处是接收的topic模式的消息123456789101112131415161718192021222324import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jms.annotation.JmsListener;import org.springframework.stereotype.Service;@Servicepublic class ReceiveMsgServiceImpl implements ReceiveMsgService &#123; private static final Logger logger = LoggerFactory.getLogger(ReceiveMsgServiceImpl.class); @JmsListener(destination = QueueList.TOPIC_RECEIVE, containerFactory = &quot;jmsListenerContainerTopic&quot;) @Override public void getQueueMessageText(String message) &#123; try &#123; logger.info(&quot;activemq收到消息：&#123;&#125;&quot;, message); // ... &#125; catch (IOException e) &#123; // ... &#125; &#125;&#125; 队列的定义12345678910111213import org.apache.activemq.command.ActiveMQQueue;import org.springframework.context.annotation.Bean;import org.springframework.stereotype.Component;/** * 消息队列 */@Componentpublic class QueueList &#123; public static final String QUEUE_SEND = &quot;queue_send&quot;; public static final String TOPIC_RECEIVE = &quot;topic_receive&quot;;&#125; 异常错误Could not connect to broker URL问题： Could not refresh JMS Connection for destination ‘queue_toc_tob’ - retrying using FixedBackOff{interval=10000, currentAttempts=2013, maxAttempts=unlimited}. Cause: Could not connect to broker URL: tcp://localhost:61616. Reason: java.net.ConnectException: Connection refused分析： activemq正常启动着，数据量小没有问题，通过 nestat -nalp |grep 61616 发现有很多连接。解决： 使用连接池。1、在pom.xml中：（springboot使用1.5.6.RELEASE版本）123456789 &lt;!-- activemq support --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-pool&lt;/artifactId&gt;&lt;/dependency&gt; 2、在application.yml中：12345678spring: activemq: 。。。。。。 pool: enabled: true max-connections: 2 expiry-timeout: 10000 idle-timeout: 30000 参考http://blog.csdn.net/q_zx1bydcom/article/details/53078870]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>activemq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot的切面aop]]></title>
    <url>%2F2017%2F05%2F17%2Fspringboot-aop%2F</url>
    <content type="text"><![CDATA[在springboot项目中使用的切面aop，打印各个请求的请求参数和相应参数。 注意：post请求和get请求获取参数的方式不同。request.getQueryString();使用与get请求12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import com.fasterxml.jackson.databind.ObjectMapper;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.context.annotation.Configuration;import org.springframework.stereotype.Component;import org.springframework.web.context.request.RequestAttributes;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import javax.servlet.http.HttpServletRequest;import java.util.Map;//描述切面类@Aspect@Configuration@Componentpublic class HttpControllerAop &#123; private static final Logger logger = LoggerFactory.getLogger(HttpControllerAop.class); /** * 定义切点Pointcut */ @Pointcut(&quot;execution(* com.hfy..*HttpController.*(..))&quot;) public void excudeService() &#123; &#125; @Around(&quot;excudeService()&quot;) public Object doAround(ProceedingJoinPoint pjp) throws Throwable &#123; ObjectMapper mapper = new ObjectMapper(); RequestAttributes ra = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes sra = (ServletRequestAttributes) ra; HttpServletRequest request = sra.getRequest(); String uri = request.getRequestURI(); String queryString = request.getQueryString(); Map&lt;String, String[]&gt; params = request.getParameterMap(); if (params != null) &#123; queryString = mapper.writeValueAsString(params); &#125; String method = request.getMethod(); if (&quot;POST&quot;.equals(method)) &#123; Object[] paramsArray = pjp.getArgs(); if (paramsArray.length &gt; 0) &#123; queryString = mapper.writeValueAsString(paramsArray[0]); &#125; &#125; else &#123; queryString = request.getQueryString(); &#125; logger.info(&quot;请求uri: (&#123;&#125;), params: &#123;&#125;&quot;, uri, queryString); // result的值就是被拦截方法的返回值 Object result = pjp.proceed(); // 过滤 高频或数据量大的日志，不打印 return result; &#125;&#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>aop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot读取配置文件]]></title>
    <url>%2F2017%2F05%2F16%2Fspringboot-config%2F</url>
    <content type="text"><![CDATA[各个环境的配置文件 开发中，分为三种环境：开发（dev）、测试（test）、生产（pro） 所以，不同的环境配置文件名为：application-环境.yml。例如:application-dev.yml 在application.yml中可以配置使用哪种环境：123spring: profiles: active: dev 读取配置文件12345678910111213@Component@ConfigurationPropertiespublic class BasicProperties &#123; @Value(&quot;$&#123;server.port&#125;&quot;) // https端口 private int serverPort; @Value(&quot;$&#123;server.address&#125;&quot;) // 应用请求地址 private String serverAddress; @Value(&quot;$&#123;http.port&#125;&quot;) // http端口 private int httpPort; @Value(&quot;$&#123;url.patterns&#125;&quot;) // 数组类型 private String[] urlPatterns;&#125; 配置文件中的变量123name=张三title=测试desc=$&#123;name&#125;正在$&#123;title&#125; 配置文件获取pom.xml中的版本号1version=@project.version@ 但是1.5.6版本的springboot，不支持此种 参考Spring Boot属性配置文件详解]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot的文件上传]]></title>
    <url>%2F2017%2F05%2F15%2Fspringboot-file-upload%2F</url>
    <content type="text"><![CDATA[待总结解决异常：The temporary upload location is not valid123456789101112131415161718192021222324/** * 解决异常：The temporary upload location is not valid * http://wuzhaoyang.me/2017/06/07/spring-multipartexception-location-not-valid.html * 前端Ajax上传一张图片，服务端将文件流临时保存在文件夹里(这个文件夹由spring boot在启动的时候新建)。 * /tmp文件夹的有自动cleanup机制，/tmp文件夹的文件10天未更新会被移除，/var/tmp文件夹的文件是30天。 * 思路：指定目录，将防止文件夹被自动删除。 * @return */ @Bean MultipartConfigElement multipartConfigElement() &#123; MultipartConfigFactory factory = new MultipartConfigFactory(); String absolutePath = new File(&quot;&quot;).getAbsolutePath(); logger.info(&quot;absolutePath ===== &#123;&#125;&quot;, absolutePath); String location = absolutePath + &quot;/data/tmp&quot;; File file = new File(location); if (!file.exists()) &#123; boolean mkdirs = file.mkdirs(); logger.info(&quot;创建文件夹(&#123;&#125;)：&#123;&#125;&quot;, location, mkdirs); &#125; else &#123; logger.info(&quot;SpringBoot内置Tomcat缓存文件目录：&#123;&#125;&quot;, location); &#125; factory.setLocation(location); return factory.createMultipartConfig(); &#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot的https配置]]></title>
    <url>%2F2017%2F05%2F14%2Fspringboot-https%2F</url>
    <content type="text"></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot与redis]]></title>
    <url>%2F2017%2F05%2F13%2Fspringboot-redis%2F</url>
    <content type="text"></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springmvc与分页]]></title>
    <url>%2F2017%2F05%2F12%2Fspringmvc-page%2F</url>
    <content type="text"></content>
      <categories>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery WEUI的datetimePicker使用]]></title>
    <url>%2F2017%2F05%2F11%2Fjquery-weui-datetimepicker%2F</url>
    <content type="text"><![CDATA[此处主要记录，两个日期，截止时间不能大于开始时间1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;!-- 省略 --&gt; &lt;!-- head 中 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://cdn.bootcss.com/weui/0.4.3/style/weui.min.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://cdn.bootcss.com/jquery-weui/0.8.0/css/jquery-weui.min.css&quot;&gt; &lt;/head&gt; &lt;body ontouchstart&gt; &lt;div class=&quot;weui_cells weui_cells_form&quot;&gt; &lt;div class=&quot;weui_cell&quot;&gt; &lt;div class=&quot;weui_cell_hd&quot;&gt;&lt;label class=&quot;weui_label&quot;&gt;起始时间&lt;/label&gt;&lt;/div&gt; &lt;div class=&quot;weui_cell_bd weui_cell_primary&quot;&gt; &lt;input type=&quot;text&quot; id=&apos;startTime&apos; class=&quot;weui_input&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;weui_cell&quot;&gt; &lt;div class=&quot;weui_cell_hd&quot;&gt;&lt;label class=&quot;weui_label&quot;&gt;终止时间&lt;/label&gt;&lt;/div&gt; &lt;div class=&quot;weui_cell_bd weui_cell_primary&quot; id=&quot;endTimeDiv&quot;&gt; &lt;input type=&quot;text&quot; id=&apos;endTime&apos; class=&quot;weui_input&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- body 最后 --&gt; &lt;!-- body 最后 --&gt; &lt;script src=&quot;http://cdn.bootcss.com/jquery/1.11.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://cdn.bootcss.com/jquery-weui/0.8.0/js/jquery-weui.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot; &gt; var curDateStr = &apos;2017-10-12 10:10&apos;; $(&quot;#startTime&quot;).datetimePicker(&#123; title: &apos;请选择起始时间&apos;, min : curDateStr, value: curDateStr, onClose: function(p) &#123; // 起始时间改变，更改终止时间的最小值 console.log(p.value); // 获取新起始时间 var year = p.value[0]; var month = p.value[1]; var day = p.value[2]; var hour = p.value[3]; var minute = p.value[4]; var dateStr = year + &quot;-&quot; + month + &quot;-&quot; + day + &quot; &quot; + hour + &quot;:&quot; + minute; var date = new Date(Date.parse(dateStr.replace(/-/g, &quot;/&quot;))); console.log(dateStr); // 获取旧终止时间 var oldEndTimeStr = $(&quot;#endTime&quot;).val(); var oldEndTime = new Date(Date.parse(oldEndTimeStr.replace(/-/g, &quot;/&quot;))); // 旧终止时间&gt;新的起始时间，不更改终止时间，否则，更新 var newEndTimeStr; if (oldEndTime &lt; date) &#123; newEndTimeStr = dateStr; &#125; else &#123; newEndTimeStr = oldEndTimeStr; &#125; $(&quot;#endTime&quot;).remove(); $(&quot;#endTimeDiv&quot;).append(&apos;&lt;input type=&quot;text&quot; id=&quot;endTime&quot; class=&quot;weui_input&quot; /&gt;&apos;); $(&quot;#endTime&quot;).datetimePicker(&#123; title: &apos;请选择终止时间&apos;, min: dateStr, value: newEndTimeStr &#125;); &#125; &#125;); $(&quot;#endTime&quot;).datetimePicker(&#123; title: &apos;请选择终止时间&apos;, min : curDateStr, value: curDateStr &#125;); &lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>jquery WEUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html中的那些事]]></title>
    <url>%2F2017%2F05%2F11%2Fjs-json%2F</url>
    <content type="text"><![CDATA[json与其他类型之间的转换，推送消息 json与字符串12var obj = JSON.parse(str); //由JSON字符串转换为JSON对象var last=JSON.stringify(obj); //将JSON对象转化为JSON字符 好的文章]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>json</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中日期相关问题]]></title>
    <url>%2F2017%2F05%2F11%2Fjs-date%2F</url>
    <content type="text"><![CDATA[自己一些总结 日期转换日期转字符串123456789function convertDate2String(datetime)&#123; var year = datetime.getFullYear(); var month = datetime.getMonth() + 1 &lt; 10 ? &quot;0&quot; + (datetime.getMonth() + 1) : datetime.getMonth() + 1; var date = datetime.getDate() &lt; 10 ? &quot;0&quot; + datetime.getDate() : datetime.getDate(); var hour = datetime.getHours()&lt; 10 ? &quot;0&quot; + datetime.getHours() : datetime.getHours(); var minute = datetime.getMinutes()&lt; 10 ? &quot;0&quot; + datetime.getMinutes() : datetime.getMinutes(); var second = datetime.getSeconds()&lt; 10 ? &quot;0&quot; + datetime.getSeconds() : datetime.getSeconds(); return year + &quot;-&quot; + month + &quot;-&quot; + date+&quot; &quot;+hour+&quot;:&quot;+minute;&#125; 字符串转日期12var oldEndTimeStr = &apos;2017-06-03 11:50&apos;;var oldEndTime = new Date(Date.parse(oldEndTimeStr.replace(/-/g, &quot;/&quot;))); 日期增减1234567891011121314151617//根据日期字符串计算月份差 (日期格式为&quot;yyyy-MM-dd&quot;,根据自己需要改格式和方法)function getMonthNumber(date1,date2)&#123; date1 = date1.split(&quot;-&quot;); date2 = date2.split(&quot;-&quot;); var year1 = date1[0]; var year2 = date2[0]; var month1 = date1[1]; var month2 = date2[1]; var day1 = date1[2]; var day2 = date2[2]; var len=(year2-year1)*12+(month2-month1); if (day1 &gt;= day2) &#123; len = len - 1; &#125; return len;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis中的mapper]]></title>
    <url>%2F2017%2F05%2F11%2Fmybatis-sql%2F</url>
    <content type="text"><![CDATA[插入后返回主键、关联查询、多参 xml格式插入后返回主键12&lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.hfy.db.bean.User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;&lt;/insert&gt; 多个参数 对于接口中多个请求参数，没有封装成对象12345678910111213// dao中:OrderDetail selectByTypeAndDate(@Param(&quot;type&quot;)Integer type, @Param(&quot;date&quot;)String date);// mapper中：&lt;select id=&quot;selectByTypeAndDate&quot; resultMap=&quot;orderDetailResult&quot; &gt; SELECT * FROM order_detail WHERE type = #&#123;type&#125; &lt;c:if test=&quot;type == 1&quot;&gt; and minPlayTime &gt; #&#123;date&#125; &lt;/c:if&gt; &lt;c:if test=&quot;type == 2&quot;&gt; and maxPlayTime &lt; #&#123;date&#125; &lt;/c:if&gt;&lt;/select&gt; 关联查询 123456&lt;resultMap type=&quot;com.hfy.db.bean.Order&quot; id=&quot;OrderResult&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;!-- 配置关联关系 --&gt; &lt;association property=&quot;user&quot; column=&quot;userId&quot; select=&quot;com.hfy.dao.UserDao.selectById&quot;&gt;&lt;/association&gt; &lt;/resultMap&gt; 注解格式插入后返回主键12@Insert(&quot;&quot;)@SelectKey(statement = &quot;SELECT LAST_INSERT_ID()&quot;, keyProperty = &quot;user.id&quot;, resultType = int.class, before = false) MyBatis注解select in参数1234567/** * * @param ids &apos;1,2,3&apos; * @return */@Select(&quot;select * from user where id in ($&#123;ids&#125;)&quot;)List&lt;UserInfo&gt; getUserbyIds(@Param(&quot;ids&quot;)String ids); MyBatis注解list参数注解中想使用xml中的&lt;if&gt;标签，需要用&lt;script&gt;标签将其包起来123456789101112&lt;script&gt;insert into tb_image_temp( &lt;foreach collection=&apos;keys&apos; item=&apos;item&apos; open=&apos;(&apos; separator=&apos;,&apos; close=&apos;)&apos;&gt; $&#123;item&#125; &lt;/foreach&gt;) values( &lt;foreach collection=&apos;values&apos; item=&apos;item&apos; open=&apos;(&apos; separator=&apos;,&apos; close=&apos;)&apos;&gt; #&#123;item&#125; &lt;/foreach&gt;)&lt;/script&gt; 12345678@Update(&quot;&lt;script&gt;\n&quot; + &quot; update $&#123;tableName&#125; set &quot; + &quot; &lt;foreach collection=&apos;map&apos; index=&apos;key&apos; item=&apos;item&apos; open=&apos;&apos; separator=&apos;,&apos; close=&apos;&apos; &gt;\n&quot; + &quot; $&#123;key&#125; = #&#123;item&#125;\n&quot; + &quot; &lt;/foreach&gt;\n&quot; + &quot; where id = #&#123;id&#125;\n&quot; + &quot;&lt;/script&gt;&quot;)void updateImage(@Param(&quot;tableName&quot;) String tableName, @Param(&quot;map&quot;) Map&lt;String, Object&gt; map, @Param(&quot;id&quot;) Integer id);]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux相关知识]]></title>
    <url>%2F2017%2F05%2F11%2Flinux-command%2F</url>
    <content type="text"><![CDATA[linux常用命令，和安装一些软件，以及一些基础知识 [CPU状态信息us,sy,ni,id,wa,hi,si,st含义]（http://blog.csdn.net/sasoritattoo/article/details/9318893） 常用命令1、启动jar包：java -jar test.jar2、在后台启动jar：nohup java -jar test.jar 2&gt;&amp;1 &gt;/dev/null &amp; 当然，我们可以将其写到sh脚本中。然后sh start.sh 执行脚本即可。 其中，start.sh是个脚本。里面内容是：1234test=`dirname &quot;$0&quot;`cd $testnohup java -jar test.jar 2&gt;&amp;1 &gt;/dev/null &amp;cd - 3、查看java程序是否启动：ps -ef | grep java （每天一个linux命令（41）：ps命令）4、根据端口查看进行：netstat -anp | grep 80805、杀掉进程： kill -9 4564 4564是进程号，通过上一个命令查看（第二列） 6、查看目录大小：du -h df -h（命令详解请看linux的du和df命令、df, du, ls 的区别）7、更改密码 8、查看打开文件数量：lsof -p 端口号 | wc -l9、修改IP地址： 编辑：vi /etc/sysconfig/network-scripts/ifcfg-eth0，完成后，service network restart或/etc/init.d/network restart重启网络服务，然后ping网关，ping外网进行测试。都能ping通表示网络正常。详细参考：https://jingyan.baidu.com/article/ca2d939d2cf1aceb6c31ce0a.html 创建git仓库1、创建文件夹：mkdir test.git2、进入目录：cd test.git3、git初始化：git init --bare4、创建快捷方式：ln -s /home/git/test.git（软连接相当于windows的快捷方式） mysql6.0以后1、启动：/bin/systemctl start mariadb2、停止：/bin/systemctl stop mariadb3、查看: systemctl status mariadb.service 安装redis安装activemq安装中文字体去网上下载字体：例如：微软雅黑：http://www.mycode.net.cn/wp-content/uploads/2015/07/YaHeiConsolas.tar.gz 查看当前系统已经安装的中文字体：fc-list :lang=zh 字体安装步骤：1、解压压缩包到任意普通目录cd /home/hfy/test/tar -zxvf YaHeiConsolas.tar.gz2、在系统目录下创建自定义字体目录（必须要sudo）sudo mkdir -p /usr/share/fonts/chinese/msyh3、复制解压出来的字体到刚才创建的目录sudo cp YaHeiConsolas.ttf /usr/share/fonts/chinese/msyh4、进入字体目录cd /usr/share/fonts/chinese/msyh5、刷新并安装字体sudo mkfontscale &amp;&amp; sudo mkfontdir &amp;&amp; sudo fc-cache -fv]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdk生成https证书]]></title>
    <url>%2F2017%2F05%2F11%2Fjava-https-cert%2F</url>
    <content type="text"><![CDATA[待总结]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springmvc+mybatis事务不起作用]]></title>
    <url>%2F2017%2F05%2F11%2Fspringmvc-transaction%2F</url>
    <content type="text"><![CDATA[http://blog.csdn.net/liuxiao723846/article/details/43483101]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot与swagger]]></title>
    <url>%2F2017%2F05%2F11%2Fspringboot-swagger%2F</url>
    <content type="text"><![CDATA[springboot项目中使用swagger，快速生成api pom中引入1234567891011&lt;!-- swagger --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; swagger配置 支持在配置文件中配置是否显示api，需要显示api的接口uri。(此处使用到了在springboot中读取配置文件信息的知识。springboot读取配置文件)123456789101112131415161718192021222324252627282930313233343536373839@EnableSwagger2@Componentpublic class Swagger2 &#123; @Autowired private BasicProperties basicProperties; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .enable(basicProperties.getSwaggerShow()) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.hfy&quot;))// .paths(PathSelectors.any()) //.paths(PathSelectors.regex(&quot;/ab/*&quot;)) //.apis(RequestHandlerSelectors.withClassAnnotation(Api.class)) //.apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class)) .paths(path()) .build(); &#125; private Predicate&lt;String&gt; path() &#123; List&lt;Predicate&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(); for (String pattern : basicProperties.getSwaggerPatterns()) &#123; list.add(PathSelectors.regex(pattern)); &#125; return Predicates.or(list); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;APIs&quot;) .contact(&quot;hfy&quot;) .version(&quot;1.0&quot;) .build(); &#125;&#125; 待完成 暂时没做到：swagger中搜索不可用。 参考Spring Boot中使用Swagger2构建强大的RESTful API文档SpringBoot项目生成RESTfull API的文档]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot的测试]]></title>
    <url>%2F2017%2F05%2F11%2Fspringboot-test%2F</url>
    <content type="text"><![CDATA[测试代码以下是1.3版本的测试12345678import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTest(classes = App.class)public class BaseTest &#123;&#125; 以下是1.4.0 版本的测试123456789101112import org.junit.runner.RunWith;import org.springframework.boot.test.SpringApplicationConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import javax.servlet.ServletContext;@RunWith(SpringJUnit4ClassRunner.class) // SpringJUnit支持，由此引入Spring-Test框架支持！@SpringApplicationConfiguration(classes = App.class) // 指定我们SpringBoot工程的Application启动类@WebAppConfigurationpublic class BaseTest &#123;&#125; MockMVC测试调用方法之前，获取登录后session。12345678910111213141516171819202122232425262728293031323334353637@Autowiredprivate WebApplicationContext context;private MockMvc mockMvc;private MockHttpSession session;@Beforepublic void setupMockMvc() throws Exception &#123; mockMvc = MockMvcBuilders.webAppContextSetup(context).build(); getLoginSession(&quot;hfy&quot;, &quot;111111&quot;);&#125;// 获取登入信息sessionprivate void getLoginSession(String name, String pwd) throws Exception &#123; MvcResult result = this.mockMvc .perform(post(&quot;/index.action&quot;) .contentType(MediaType.APPLICATION_FORM_URLENCODED) .param(&quot;loginname&quot;, name) .param(&quot;password&quot;, pwd)) .andReturn(); Assert.assertEquals(&quot;main/index&quot;, result.getModelAndView().getViewName()); this.session = (MockHttpSession) result.getRequest().getSession();&#125;@Testpublic void testPerson() throws Exception &#123; MockHttpServletRequestBuilder builder = post(&quot;/person/editPerson.action&quot;) .param(&quot;personId&quot;, &quot;1&quot;) .param(&quot;name&quot;, &quot;xx&quot;).session(session); MvcResult mvcResult = mockMvc.perform(builder).andReturn(); System.out.println(mvcResult.getResponse().getContentAsString()); Map map = new ObjectMapper().readValue(mvcResult.getResponse().getContentAsString(), Map.class); Assert.assertEquals(&quot;success&quot;, map.get(&quot;result&quot;));&#125; 参考Spring Boot应用的测试——MockitoSpring MVC 测试 | 模拟提交表单Junit测试Controller（MockMVC使用），传输@RequestBody数据解决办法sonar + jacoco + mockMvc 模拟session 用户登录 配合SpringSecurity 权限 快速测试代码覆盖率]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery WEUI的分页加载]]></title>
    <url>%2F2017%2F05%2F11%2Fjquery-weui-page%2F</url>
    <content type="text"><![CDATA[主要记录，分页加载12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;!-- 省略 --&gt; &lt;!-- head 中 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.bootcss.com/weui/0.4.3/style/weui.min.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.bootcss.com/jquery-weui/0.8.0/css/jquery-weui.min.css&quot;&gt; &lt;/head&gt; &lt;body ontouchstart&gt; &lt;div class=&quot;weui_cells&quot; id=&quot;list&quot;&gt; &lt;/div&gt; &lt;div class=&quot;weui-infinite-scroll&quot; id=&quot;scroll&quot;&gt; &lt;div class=&quot;infinite-preloader&quot;&gt;&lt;/div&gt; 正在加载... &lt;/div&gt; &lt;!-- body 最后 --&gt; &lt;script src=&quot;http://cdn.bootcss.com/jquery/1.11.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://cdn.bootcss.com/jquery-weui/0.8.0/js/jquery-weui.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot; &gt; var records = []; var havaData = false; var count = -1; var jsonData = &#123;&#125;; function getData(jsonData)&#123; $.get(&quot;http://xx&quot;,jsonData,function(data)&#123; console.log(data); if (data.result == &apos;success&apos;) &#123; records = data.list; count = data.count; // 数据总条数 if(records.length == 0 &amp;&amp; !havaData)&#123; $(&quot;#scroll&quot;).hide(); $.alert(&quot;没有记录！&quot;); &#125;else&#123; havaData = true; &#125; // 显示数据 showData(records); &#125; else &#123; $.alert(&quot;加载数据失败!&quot;); $(document.body).destroyInfinite(); $(&quot;#scroll&quot;).hide(); &#125; &#125;,&quot;json&quot;); &#125; // 页面一进来就获取数据 getData(jsonData); function showData(records)&#123; var length = records.length; for(var i = 0; i &lt; length; i++)&#123; var div = document.getElementById(&quot;list&quot;); var str= &quot;显示数据&lt;br&gt;&quot;; div.innerHTML =div.innerHTML+str; &#125; if(length == 0)&#123; $(&quot;#scroll&quot;).hide(); &#125; &#125; // 滚动条滑动到离底部100，多显示一条数据。 显示后不会消失。 $(document.body).infinite(100); var loading = false; //状态标记 否则一直循环刷新 $(document.body).infinite().on(&quot;infinite&quot;, function() &#123; if(loading) return; loading = true; setTimeout(function() &#123; var length = records.length; if(length &gt; 0 &amp;&amp; havaData)&#123; // 还有数据，继续加载 start = start + 5; var jsonData = &#123;&#125;; getData(jsonData); &#125;else&#123; havaData = false; $.alert(&quot;全部数据已经加载完成！&quot;); $(document.body).destroyInfinite(); $(&quot;#scroll&quot;).hide(); return; &#125; loading = false; &#125;,50); //模拟延迟 &#125;); &lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>jquery WEUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支付]]></title>
    <url>%2F2017%2F05%2F11%2Fpay%2F</url>
    <content type="text"><![CDATA[支付宝、微信支付自己一些总结 支付宝异步通知签名失败app支付，app端可以调起支付，支付成功后异步通知，签名校验失败，原因是：使用的是“应用公钥”，应该用“支付宝公钥”。查看地址：https://openhome.alipay.com/platform/keyManage.htm 微信一个二维码支付一个二维码微信支付宝均可付款1、判断扫描来源是微信还是支付宝；2、进行不同的操作；如果是微信，我采用jsApi支付。跳转到微信公众号支付下面。因为微信二维码支付的码串不是链接，所以放弃了。注意：有可能没有关注微信公众号，此链接支持：授权1location.href = &quot;https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx19eba09adbcda9da&amp;redirect_uri=xxxx&amp;response_type=code&amp;scope=snsapi_base&amp;state=fff&amp;connect_redirect=1#wechat_redirect&quot;; 如果是支付宝，本人采用的是获取支付二维码方式：（因为支付宝码串是https链接，可直接跳转）本人不知还有什么更好的办法，欢迎网友们提提建议。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>pay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springmvc与swagger]]></title>
    <url>%2F2017%2F05%2F11%2Fspringmvc-swagger%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>swagger</tag>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js获得get传过来的参数]]></title>
    <url>%2F2017%2F05%2F11%2Fjs-get-reqparam%2F</url>
    <content type="text"><![CDATA[自己一些总结12345678910111213141516171819//获得页面传过来的参数 function getParam() &#123; var urlInfo = decodeURIComponent(window.location.href); //获取当前页面的url var intLen = urlInfo.length; //获取url的长度 var offset = urlInfo.indexOf(&quot;?&quot;); //设置参数字符串开始的位置 var strKeyValue = urlInfo.substr(offset+1, intLen); //取出参数字符串 这里会获得类似“id=1”这样的字符串 var arrParam = strKeyValue.split(&quot;&amp;&quot;); //对获得的参数字符串按照“=”进行分割 var map = &#123;&#125;; for(var i in arrParam)&#123; var temp = arrParam[i]; var val = temp.split(&quot;=&quot;); map[val[0]] = val[1]; &#125; return map; &#125; var map = getParam();var startTime = map[&quot;startTime&quot;];]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令expect]]></title>
    <url>%2F2017%2F05%2F11%2Flinux-expect%2F</url>
    <content type="text"><![CDATA[自己一些总结 参考expect用法]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows常用命令]]></title>
    <url>%2F2017%2F05%2F11%2Fwindows%2F</url>
    <content type="text"><![CDATA[windows常用命令查看进程：cmd /c netstat -aon| findstr 端口杀掉进程：taskkill /F /pid 进程号]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php]]></title>
    <url>%2F2017%2F05%2F11%2Fphp%2F</url>
    <content type="text"><![CDATA[自己一些总结用全局变量。123456789class MyClass &#123; public my_print() &#123; global 搜索$str; print $str; &#125;&#125;$str = &apos;Hello, World&apos;.$myclass = new MyClass();$myclass-&gt;my_print(); 12345include_once(&quot;config.php&quot;);class WxPayConfig&#123; const A = Config::A;&#125; 1234567&lt;?php class Config&#123; const KEY = &apos;111&apos;; static $URL = &quot;&quot;; &#125; Config::$URL_GET_TOKEN = &quot;http://127.0.0.1:8890/user/add?key=&quot;.Config::KEY;?&gt; php实现返回上一页1echo&quot;&lt;script&gt;alert(&apos;随便写点什么&apos;);history.go(-1);&lt;/script&gt;&quot;; 参考php的class中怎样引用外部的变量PHP类中的静态方法使用实例关于PHP对象实例化单个例子的方法通过http post发送json数据php与js相互调用php json]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql相关知识]]></title>
    <url>%2F2017%2F05%2F11%2Fmysql%2F</url>
    <content type="text"><![CDATA[更改数据库密码，触发器，数据插入，备份数据等 更改数据库密码12update mysql.user set password=password(&apos;123456&apos;);flush privileges; 触发器MYSQL触发器自己更新自己错误 一个表的数据插入另一个表mysql从一个表中查数据，插入另一个表1、 数据一致，想全部插入： INSERT INTO 目标表 SELECT * FROM 来源表 ;2、 导入部分数据： INSERT INTO 目标表 (字段1, 字段2, ...) SELECT 字段1, 字段2, ... FROM 来源表 ; insert into local_image(createdDate, data) SELECT &#39;2016-10-10&#39; createdDate,data FROM local_image; 其他知识1`SELECT * FROM information_schema.`PROCESSLIST` t WHERE t.`COMMAND` != &apos;Sleep&apos;; show processlist结果筛选 https://www.2cto.com/database/201309/246586.html 导出库1、导出结构不导出数据 mysqldump -d 数据库名 -uroot -p &gt; xxx.sql2、导出数据不导出结构 mysqldump -t 数据库名 -uroot -p &gt; xxx.sql3、导出数据和表结构 mysqldump 数据库名 -uroot -p &gt; xxx.sql4、导出特定表的结构 mysqldump -u root -p 数据库名 –table 表名 &gt; xxx.sql mysqldump参数1、备份出test库表中表的结构和数据（除了image表）1D:\mysql\bin&gt;mysqldump --single-transaction --ignore-table=test.image -u root -p test &gt; bak.sql 2、备份出test库表中表image的结构和数据（数据的条件是id &gt; 2） mysqldump -u用户名 -p密码 数据库名 表名 –where=”筛选条件” &gt; 导出文件路径1D:\mysql\bin&gt;mysqldump -u root -p test image --where=&quot; id &gt; 2 &quot; &gt; image.sql 具体参数详情：MYSQL使用mysqldump导出某个表的部分数据 导入数据mysql 数据库名 &lt; 文件名source /tmp/xxx.sql group_concatMySQL中group_concat函数,连接字段，多个值显示为一行 事务truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.SQL中truncate table和delete的区别]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github搭建自己的网站]]></title>
    <url>%2F2017%2F03%2F25%2Fhexo-github%2F</url>
    <content type="text"><![CDATA[搭建博客简单介绍 安装nodejs(官网下载安装包安装即可) 点击进入node.js官网,下载完成后安装即可 安装git 进入官网下载，安装 安装hexo 1、首先，创建文件夹用来存放你的本地博客。本人的博客存放在d:/blog文件夹下2、打开git窗口3、输入以下命令，进入到d:/blog cd d: cd blog 其中，cd 文件夹 的意思便是进入到某个文件夹4、一次性安装完hexo所需的所有东西1234npm install hexo-cli -g npm install hexo --save npm install hexo-deployer-git --save npm install 安装速度慢，可以使用淘宝镜像：1 npm install cnpm -g --registry=https://registry.npm.taobao.org 5、安装完成，我们可以看到文件夹下已经生成了很多东西，依次在git中执行以下命令：123 hexo clean hexo g hexo s 此时命令行会提示http://localhost:4000/，我们在浏览器中打开该链接，一个hello的博客就完成了。(#^.^#) 博客使用创建新文章打开hexo安装目录\source\文件夹，发现只有_posts一个文件夹，创建分类和标签。1、执行命令hexo new categories，修改hexo安装目录\source\categories下的index.md文件：123456---title: 分类date: 2016-07-16 04:36:09type: &quot;categories&quot;comments: false--- 2、执行命令hexo new tags,hexo安装目录\source\tags下的index.md文件：123456---title: 标签云date: 2016-07-16 04:32:03type: &quot;tags&quot;comments: false--- 3、执行命令hexo new “first blog”，创建博客（或者直接在hexo安装目录\source_posts创建一个.md文件，里面写入以下内容）123456---title: 本人创建的第一篇 date: 2017-03-25 13:53:30 tags: 写作 categories: 随笔 --- 博客主题 hexo有很多主题，找到自己喜欢的，点击图片预览博客样子，点击名称会进入github中。在github中将源码下载下来，解压放入themes文件夹中，修改_config.yml：theme: yelee 表示使用themes文件夹下yelee文件夹中的主题。 使用next主题（网上很多，此处记下可能遇到的问题）(1) 使用中文语言： 修改（hexo安装目录_config.yml）文件：(不是themes\next_config.yml) language: zh-Hans(3) 部署到github上js、css找不到 修改（hexo安装目录_config.yml）文件： root: /blog/ #blog是你github上面的仓库名称 部署到github当前，首先得在github上注册一个账号，然后，1、github上创建一个仓库 仓库名称(Repository name)可以写成blog。github自动生成的网址会是：https://账户名称.github.io/仓库名称/ ，此时，如果仓库名称写成账户名称.github.io,那么，github自动生成的网址会是：https://账户名称.github.io/ （记得勾选Initialize this repository with a README） 在项目的settings中，GitHub Pages中选择master branch，save后，会生成url。之后将本地的博客部署到这里，访问该网址，便ok啦！2、使用git部署hexo到github:(1)设置git git使用hexo deploy部署的时候，保证user.name和github账上上的账户名一致。 查看用户名 ：git config --list 如果首次安装，没有设置，可以使用下面命令：12git config --global user.name &quot;ff&quot; git config --global user.email &quot;liuchao102@163.com&quot; 如果已经设置好了，向修改：vi ~/.gitconfig 按下i键，修改，dd删除一行，esc退出编辑。按住shift，wq保存(2)生成ssh秘钥 要部署到github上，本地要有权限。在git中生成秘钥1ssh-keygen -t rsa -C &quot;xxx@163.com&quot; 生成完秘钥之后会在 C:\Users\Administrator\.ssh 目录下生成 id_rsa和id_rsa.pub两个文件 拷贝id_rsa.pub文件内容到 github上就可以了(Settings-&gt;SSH and GPG keys-&gt;new SSH Key -&gt; 输入文件内容 -&gt; 保存完成)(3)执行以下命令部署：1hexo deploy 使用atom实现预览编辑文档 atom安装插件atom-hexo，速度很慢，可以使用本地安装： 在github上下载好后解压到C:\Users\cage.atom\packages，cmd打开命令行输入：apm install安装即可。 如果apm命令找不到，在环境变量中加入: C:\Users\hfyuser\AppData\Local\atom\bin atom自带markdown preview，编写md可以实时浏览。 参考置顶文章20分钟教你使用hexo搭建github博客Gitment：使用 GitHub Issues 搭建评论系统如何用好 github 中的 watch、star、fork如何正确接收 GitHub 的消息邮件github fork项目后，代码更新]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lombok学习]]></title>
    <url>%2F2017%2F01%2F11%2Flombok%2F</url>
    <content type="text"><![CDATA[lombok的学习 在github上看开源代码，发现maven中用了org.projectlombok，一查询，相见恨晚的感觉啊！ lombok简介 lombok是个什么东东呢？嘿嘿，是通过注解形式帮我们减少一些代码的书写，比如getter、setter、stream的close，null的判断等。 官网：http://projectlombok.org/ 安装1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 常用注解@Getter: 生成get方法，是类、成员变量注解。@Setter: 生成set方法，是类、成员变量注解。@Data: 生成get、set、toString、equals、hashCode方法、空构造器，是类注解。@ToString: 生成toString方法，是类注解。@Log4j ： 注解在类上；为类提供一个 属性名为log 的 log4j 日志对象。@EqualsAndHashCode： 生成equals方法、hashCode方法，是类注解。@NoArgsConstructor： 注解在类上；为类提供一个无参的构造方法。@AllArgsConstructor：注解在类上；为类提供一个全参的构造方法。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>