<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springboot中的过滤器]]></title>
    <url>%2F2017%2F06%2F02%2Fspringboot-filter%2F</url>
    <content type="text"><![CDATA[做api项目，各个接口都有对应的权限。所以使用过滤器对各个请求进行过滤。以下是学习的简单总结。 springboot中使用filter 在springboot项目中使用filter，需要注入bean：123456789101112131415161718@SpringBootApplication //等同于 @Configuration @EnableAutoConfiguration @ComponentScanpublic class SpringbootFilterDemoApp &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootFilterDemoApp.class, args); &#125; @Bean public FilterRegistrationBean filterRegistrationBean() &#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new AuthorizationFilter()); // 自己的filter List&lt;String&gt; urlPatterns = new ArrayList&lt;&gt;(); urlPatterns.add(&quot;/openapi/*&quot;); registrationBean.setUrlPatterns(urlPatterns); return registrationBean; &#125;&#125; 过滤器filter 以下是自己的filter类。继承Filter接口，对于满足条件的请求，使用filterChain.doFilter(request, response);将连接转发到目的地，不满足，则直接通过response写入错误信息。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * 过滤器：校验接口访问权限 */public class AuthorizationFilter implements Filter&#123; private static final Logger logger = LoggerFactory.getLogger(AuthorizationFilter.class); private CheckAuth checkAuth; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; // 将请求转换成HttpServletRequest 请求 HttpServletRequest req = (HttpServletRequest) servletRequest; HttpServletResponse rsp = (HttpServletResponse) servletResponse; // 取得接口URI String currentURI = req.getRequestURI(); // 注入checkAuth对象 ServletContext sc = req.getSession().getServletContext(); WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(sc); if (context != null &amp;&amp; context.getBean(&quot;checkAuth&quot;) != null &amp;&amp; checkAuth == null) &#123; checkAuth = context.getBean(CheckAuth.class); &#125; // 读取请求参数 // stream流的意思就是说当你读取之后就无法回到上一次读取的数据。所以说流是单向的。当第一个filter中读取流之后流已经被读完。所以无法继续读取。所以第二个filter中读不到数据。 // 防止流读取一次后就没有了, 所以需要将流继续写出去 String strError; ServletRequest requestWrapper = null; String accessToken = &quot;&quot;; // get、post获取请求参数的方式是不一样的。 if (req.getMethod().equals(&quot;POST&quot;)) &#123; requestWrapper = new HttpServletRequestWrapper(req); String reqParamsStr = HttpHelper.getBodyString(requestWrapper); logger.info(&quot;请求uri：(&#123;&#125;), 参数：&#123;&#125;&quot;, currentURI, reqParamsStr); if(reqParamsStr.length() &gt;0) &#123; // 从json字符串获取参数 accessToken = &quot;&quot;; &#125; &#125; else if (req.getMethod().equals(&quot;GET&quot;)) &#123; requestWrapper = req; logger.info(&quot;请求uri：(&#123;&#125;), 参数：&#123;&#125;&quot;, currentURI, ObjectMapperUtils.getObjectMapper().writeValueAsString(req.getParameterMap())); String[] tokens = req.getParameterValues(&quot;accessToken&quot;); if (tokens != null &amp;&amp; tokens.length &gt; 0) &#123; accessToken = tokens[0]; &#125; &#125; if (requestWrapper == null) &#123; strError = &quot;请求方式错误！&quot;; &#125; else &#123; if (checkAuth != null) &#123; if (&quot;&quot;.equals(accessToken)) &#123; strError = &quot;缺少必要的参数&quot;; &#125; else &#123; // 校验接口权限 if (checkAuth != null &amp;&amp; checkAuth.checkAuth(accessToken, currentURI)) &#123; // Filter 只是链式处理，请求依然转发到目的地址。 filterChain.doFilter(requestWrapper, rsp); return; &#125; else &#123; strError = &quot;权限不足&quot;; &#125; &#125; &#125; else &#123; strError = &quot;服务器异常&quot;; logger.error(&quot;过滤器中未能获取到checkAuth对象！&quot;); &#125; &#125; rsp.setCharacterEncoding(&quot;UTF-8&quot;); rsp.setContentType(&quot;application/json; charset=utf-8&quot;); String rspValue = &quot;&quot;; // 返回错误json信息 logger.info(&quot;返回：&#123;&#125;&quot;, rspValue); rsp.getWriter().write(rspValue); &#125; @Override public void destroy() &#123; &#125;&#125; 注意事项 filter中注入对象 filter的加载在servlet之前。所以在Filter中使用@Autowired注入对象CheckAuth肯定会失败。我们可以使用WebApplicationContextUtils来获取对象。(可参考：web.xml 中的listener、 filter、servlet 加载顺序及其详解)123456// 注入checkAuth对象ServletContext sc = req.getSession().getServletContext();WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(sc);if (context != null &amp;&amp; context.getBean(&quot;checkAuth&quot;) != null &amp;&amp; checkAuth == null) &#123; checkAuth = context.getBean(CheckAuth.class);&#125; 流的读取 读取请求参数：对于post请求，我们通过stream流进行读取，但是会发现，直接读取response流中的数据后，使用filterChain.doFilter(requestWrapper, rsp);请求，会报错：没有请求内容。 因为： stream流的意思就是说当你读取之后就无法回到上一次读取的数据。所以说流是单向的。当第一个filter中读取流之后流已经被读完。所以无法继续读取。所以第二个filter中读不到数据。 为了防止流读取一次后就没有了, 所以需要将流继续写出去。 下面是对Request的封装。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.io.BufferedReader;import java.io.ByteArrayInputStream; import java.io.IOException; import java.io.InputStreamReader; import java.nio.charset.Charset; import java.util.Enumeration; import javax.servlet.ReadListener;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;/** * httpServletRequst封装类 */public class HttpServletRequestWrapper extends javax.servlet.http.HttpServletRequestWrapper &#123; private final byte[] body; public HttpServletRequestWrapper(HttpServletRequest request) throws IOException &#123; super(request); body = HttpHelper.getBodyString(request).getBytes(Charset.forName(&quot;UTF-8&quot;)); &#125; @Override public BufferedReader getReader() throws IOException &#123; return new BufferedReader(new InputStreamReader(getInputStream())); &#125; @Override public ServletInputStream getInputStream() throws IOException &#123; final ByteArrayInputStream bais = new ByteArrayInputStream(body); return new ServletInputStream() &#123; @Override public boolean isFinished() &#123; return false; &#125; @Override public boolean isReady() &#123; return false; &#125; @Override public void setReadListener(ReadListener listener) &#123; &#125; @Override public int read() throws IOException &#123; return bais.read(); &#125; &#125;; &#125; @Override public String getHeader(String name) &#123; return super.getHeader(name); &#125; @Override public Enumeration&lt;String&gt; getHeaderNames() &#123; return super.getHeaderNames(); &#125; @Override public Enumeration&lt;String&gt; getHeaders(String name) &#123; return super.getHeaders(name); &#125;&#125; request读取数据工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.BufferedReader;import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.nio.charset.Charset; import javax.servlet.ServletRequest; public class HttpHelper &#123; /** * 获取请求Body * * @param request * @return */ public static String getBodyString(ServletRequest request) &#123; StringBuilder sb = new StringBuilder(); InputStream inputStream = null; BufferedReader reader = null; try &#123; inputStream = request.getInputStream(); reader = new BufferedReader(new InputStreamReader(inputStream, Charset.forName(&quot;UTF-8&quot;))); String line; while ((line = reader.readLine()) != null) &#123; sb.append(line); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (inputStream != null) &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return sb.toString(); &#125; &#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList的线程安全问题]]></title>
    <url>%2F2017%2F06%2F02%2Fjava-thread-arraylist%2F</url>
    <content type="text"><![CDATA[ArrayList是不安全的。多个线程对ArrayList操作，会出现问题。 实例1 下面这个demo，主要测试内容：三个线程，一个线程向集合中add数据，一个线程从集合中remove数据，一个线程判断如果集合中有数据，从其中获取数据。运行程序，会报错：越界异常。 以下是异常图片：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.ArrayList;import java.util.Collections;import java.util.List;public class ArrayListThreadTest &#123;// private static List&lt;String&gt; TEST_LIST = new CopyOnWriteArrayList&lt;String&gt;(); private static List&lt;String&gt; TEST_LIST = Collections.synchronizedList(new ArrayList&lt;String&gt;());// private static List&lt;String&gt; TEST_LIST = new ArrayList&lt;&gt;(); public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; TEST_LIST.add(&quot;11&quot;); System.out.println(&quot;Thread1 running&quot;); &#125; &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; TEST_LIST.clear(); System.out.println(&quot;Thread2 running&quot;); &#125; &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (TEST_LIST.size() &gt; 0) &#123; int size = TEST_LIST.size(); System.out.println(size + &quot;====&quot;); System.out.println(size + &quot;===&quot; + TEST_LIST.get(size-1)); &#125;// System.out.println(&quot;Thread3 running&quot;); &#125; &#125; &#125;).start(); &#125;&#125; 实例2 演示内容：多个线程向集合arraylist、线程安全的arraylist中添加数据，集合长度不同。 下面例子则来源于：http://www.oschina.net/code/snippet_70229_242512345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Random; // Java语言: ArrayList的线程安全与不安全对比演示public class ThreadSafeDemo &#123; public static int demo(final List list, final int testCount) throws InterruptedException &#123; ThreadGroup group = new ThreadGroup(list.getClass().getName() + &quot;@&quot; + list.hashCode()); final Random rand = new Random(); Runnable listAppender = new Runnable() &#123; public void run() &#123; try &#123; Thread.sleep(rand.nextInt(2)); &#125; catch (InterruptedException e) &#123; return; &#125; list.add(&quot;0&quot;); &#125; &#125;; for (int i = 0; i &lt; testCount; i++) &#123; new Thread(group, listAppender, &quot;InsertList-&quot; + i).start(); &#125; while (group.activeCount() &gt; 0) &#123; Thread.sleep(10); &#125; return list.size(); &#125; public static void main(String[] args) throws InterruptedException &#123; List unsafeList = new ArrayList(); List safeList = Collections.synchronizedList(new ArrayList()); final int N = 10000; for (int i = 0; i &lt; 10; i++) &#123; unsafeList.clear(); safeList.clear(); int unsafeSize = demo(unsafeList, N); int safeSize = demo(safeList, N); System.out.println(&quot;unsafe/safe: &quot; + unsafeSize + &quot;/&quot; + safeSize); &#125; &#125;&#125; 总结 ArrayList是线程不安全的，多线程中，我们可以使用Collections.synchronizedList(list);方法使其转换成安全的。或者我们也可以调用自己写的get、set、remove方法方法，自己方法内部加锁，调用list的get、set、remove方法1234567891011121314151617public class MessageList &#123; public static List&lt;String&gt; list = new ArrayList&lt;&gt;(); public static void addMessage(String message)&#123; synchronized (MessageList.class) &#123; list.add(message); &#125; &#125; public static void getMessage(String message)&#123; synchronized (MessageList.class) &#123; if (list.size() &gt; 0) &#123; list.remove(0); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax常见问题]]></title>
    <url>%2F2017%2F05%2F24%2Fhtml-ajax%2F</url>
    <content type="text"><![CDATA[这里主要记录用ajax时遇到的问题。 获取ajax返回结果 ajax是异步的。通常我们在succee、error中获取到后台返回的数据。如果我们想在外面获取呢？这时就需要使用responseText了。1234567891011121314151617181920212223242526var rspTxt = $.ajax(&#123; async:false, cache:false, type : &quot;POST&quot;, url : &quot;&lt;%=basePath%&gt;test.action&quot;, data : &#123; id: $(&quot;#id&quot;).val() &#125;, success : function(data) &#123; var status = data.status; if(&apos;success&apos; == status)&#123; alert(&quot;成功！&quot;); &#125;else&#123; alert(data.msg); &#125; &#125;, error:function()&#123; alert(&quot;失败！&quot;); &#125;&#125;).responseText;if(typeof(rspTxt) != &quot;undefined&quot;) &#123; var obj = JSON.parse(rspTxt); if(obj.status == &apos;success&apos;) &#123; // 业务处理 &#125;&#125; access-origin ajax如果跨域请求，会报错。即：相同主机不同端口、不同主机的访问。此种问题我们需要在服务器端进行配置 以下是springmvc项目的处理方式：1234567891011121314151617181920212223242526import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletResponse;import org.springframework.stereotype.Component;@Componentpublic class SimpleCORSFilter implements Filter &#123; public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123; HttpServletResponse response = (HttpServletResponse) res; response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE&quot;); response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;); response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;x-requested-with&quot;); chain.doFilter(req, res); &#125; public void init(FilterConfig filterConfig) &#123;&#125; public void destroy() &#123;&#125;&#125; 以下是springboot项目的处理方式：12345678910import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import org.springframework.web.bind.annotation.*;@RestController@Api(&quot;测试ajax跨域&quot;)@RequestMapping(&quot;ajaxdemo&quot;)@CrossOrigin(allowedHeaders = &quot;x-requested-with&quot;, origins = &quot;*&quot;)public class TestHttpController &#123; // ...&#125; ajax请求页面刷新 ajax请求，发现页面闪烁以下，刷新。可以配置global: false来解决123456789101112$.ajax(&#123; global: false, type : &quot;POST&quot;, url : &quot;&quot;, data : &#123; &#125;, dataType : &quot;json&quot;, success : function(data) &#123; &#125;, error : function() &#123; &#125;&#125;);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea中配置tomcat]]></title>
    <url>%2F2017%2F05%2F21%2Fidea-tomcat%2F</url>
    <content type="text"><![CDATA[在idea中添加tomcat，运行springmvc项目。 配置tomcat简单配置，参考: http://jingyan.baidu.com/album/0a52e3f43d9f69bf62ed72f9.html?picindex=2 注意问题以下是我的项目的配置：注意事项已在图中标出]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot与activemq]]></title>
    <url>%2F2017%2F05%2F18%2Fspringboot-activemq%2F</url>
    <content type="text"><![CDATA[本文章简单介绍了activemq，以及在springboot项目中使用activemq activemq介绍 ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。 ActiveMQ的消息机制： 1.点对点方式： 每个消息只能有一个消费者。 2.发布/订阅消息传递域 每个消息可以有多个消费者。 在springboot中使用配置pom文件12345&lt;!-- activemq --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;&lt;/dependency&gt; 配置工厂1234567891011121314151617181920212223242526272829303132333435import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.jms.annotation.EnableJms;import org.springframework.jms.config.DefaultJmsListenerContainerFactory;import org.springframework.jms.config.JmsListenerContainerFactory;import javax.jms.ConnectionFactory;@Configuration@EnableJmspublic class JmsConfiguration &#123; // queue模式的ListenerContainer @Bean(name = &quot;jmsListenerContainerQueue&quot;) public JmsListenerContainerFactory&lt;?&gt; jmsListenerContainerQueue(ConnectionFactory activeMQConnectionFactory) &#123; DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory(); // 实际运行时DefaultMessageListenerContainer对象将使用5000ms(5s)这个时间间隔刷新JMS连接，输出连接异常信息 // 此处使用10s重连 bean.setRecoveryInterval(10000L); bean.setConnectionFactory(activeMQConnectionFactory); return bean; &#125; // topic模式的ListenerContainer @Bean(name = &quot;jmsListenerContainerTopic&quot;) public JmsListenerContainerFactory&lt;?&gt; jmsListenerContainerTopic(ConnectionFactory activeMQConnectionFactory) &#123; DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory(); // 实际运行时DefaultMessageListenerContainer对象将使用5000ms(5s)这个时间间隔刷新JMS连接，输出连接异常信息 // 此处使用10s重连 bean.setRecoveryInterval(10000L); bean.setPubSubDomain(true); bean.setConnectionFactory(activeMQConnectionFactory); return bean; &#125;&#125; 发送消息1234567891011121314151617181920import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jms.core.JmsTemplate;import org.springframework.stereotype.Service;@Servicepublic class SendMsgServiceImpl implements SendMsgService &#123; private static final Logger logger = LoggerFactory.getLogger(SendMsgServiceImpl.class); @Autowired private JmsTemplate jmsTemplate; @Override public void sendQueueMessageText(String message) &#123; logger.info(&quot;activemq发送消息：&#123;&#125;&quot;, message); jmsTemplate.convertAndSend(QueueList.QUEUE_SEND, message); &#125;&#125; 接收消息 此处是接收的topic模式的消息123456789101112131415161718192021222324import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jms.annotation.JmsListener;import org.springframework.stereotype.Service;@Servicepublic class ReceiveMsgServiceImpl implements ReceiveMsgService &#123; private static final Logger logger = LoggerFactory.getLogger(ReceiveMsgServiceImpl.class); @JmsListener(destination = QueueList.TOPIC_RECEIVE, containerFactory = &quot;jmsListenerContainerTopic&quot;) @Override public void getQueueMessageText(String message) &#123; try &#123; logger.info(&quot;activemq收到消息：&#123;&#125;&quot;, message); // ... &#125; catch (IOException e) &#123; // ... &#125; &#125;&#125; 队列的定义12345678910111213import org.apache.activemq.command.ActiveMQQueue;import org.springframework.context.annotation.Bean;import org.springframework.stereotype.Component;/** * 消息队列 */@Componentpublic class QueueList &#123; public static final String QUEUE_SEND = &quot;queue_send&quot;; public static final String TOPIC_RECEIVE = &quot;topic_receive&quot;;&#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>activemq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot的切面aop]]></title>
    <url>%2F2017%2F05%2F17%2Fspringboot-aop%2F</url>
    <content type="text"><![CDATA[在springboot项目中使用的切面aop，打印各个请求的请求参数和相应参数。注意：post请求和get请求获取参数的方式不同。request.getQueryString();使用与get请求12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import com.fasterxml.jackson.databind.ObjectMapper;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.context.annotation.Configuration;import org.springframework.stereotype.Component;import org.springframework.web.context.request.RequestAttributes;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import javax.servlet.http.HttpServletRequest;import java.util.Map;//描述切面类@Aspect@Configuration@Componentpublic class HttpControllerAop &#123; private static final Logger logger = LoggerFactory.getLogger(HttpControllerAop.class); /** * 定义切点Pointcut */ @Pointcut(&quot;execution(* com.hfy..*HttpController.*(..))&quot;) public void excudeService() &#123; &#125; @Around(&quot;excudeService()&quot;) public Object doAround(ProceedingJoinPoint pjp) throws Throwable &#123; ObjectMapper mapper = new ObjectMapper(); RequestAttributes ra = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes sra = (ServletRequestAttributes) ra; HttpServletRequest request = sra.getRequest(); String uri = request.getRequestURI(); String queryString = request.getQueryString(); Map&lt;String, String[]&gt; params = request.getParameterMap(); if (params != null) &#123; queryString = mapper.writeValueAsString(params); &#125; String method = request.getMethod(); if (&quot;POST&quot;.equals(method)) &#123; Object[] paramsArray = pjp.getArgs(); if (paramsArray.length &gt; 0) &#123; queryString = mapper.writeValueAsString(paramsArray[0]); &#125; &#125; else &#123; queryString = request.getQueryString(); &#125; logger.info(&quot;请求uri: (&#123;&#125;), params: &#123;&#125;&quot;, uri, queryString); // result的值就是被拦截方法的返回值 Object result = pjp.proceed(); // 过滤 高频或数据量大的日志，不打印 String[] skipRsp = new String[]&#123;&quot;/getFile&quot;&#125;; boolean printRspLog = !Arrays.asList(skipRsp).contains(uri); boolean printRspLog = true; if (printRspLog) &#123; logger.info(&quot;请求结束，controller的返回值是：&#123;&#125;&quot;, mapper.writeValueAsString(result)); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>aop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot读取配置文件]]></title>
    <url>%2F2017%2F05%2F16%2Fspringboot-config%2F</url>
    <content type="text"><![CDATA[各个环境的配置文件 开发中，分为三种环境：开发（dev）、测试（test）、生产（pro） 所以，不同的环境配置文件名为：application-环境.yml。例如（application-dev.yml）在application.yml中可以配置使用哪种环境：123spring: profiles: active: dev 读取配置文件123456789101112131415@Component@ConfigurationPropertiespublic class BasicProperties &#123; @Value(&quot;$&#123;server.port&#125;&quot;) // https端口 private int serverPort; @Value(&quot;$&#123;server.address&#125;&quot;) // 应用请求地址。为了app测试方便（用户获取头像） private String serverAddress; @Value(&quot;$&#123;http.port&#125;&quot;) // http端口 private int httpPort; @Value(&quot;$&#123;http.url.patterns&#125;&quot;) // http的请求url private String[] httpUrlPatterns; @Value(&quot;$&#123;https.url.patterns&#125;&quot;) // https的请求url private String[] httpsUrlPatterns;&#125; 配置文件中的变量123com.didispace.blog.name=程序猿DDcom.didispace.blog.title=Spring Boot教程com.didispace.blog.desc=$&#123;com.didispace.blog.name&#125;正在努力写《$&#123;com.didispace.blog.title&#125;》 参考Spring Boot属性配置文件详解]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot的文件上传]]></title>
    <url>%2F2017%2F05%2F15%2Fspringboot-file-upload%2F</url>
    <content type="text"></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot的https配置]]></title>
    <url>%2F2017%2F05%2F14%2Fspringboot-https%2F</url>
    <content type="text"></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot与redis]]></title>
    <url>%2F2017%2F05%2F13%2Fspringboot-redis%2F</url>
    <content type="text"></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springmvc与分页]]></title>
    <url>%2F2017%2F05%2F12%2Fspringmvc-page%2F</url>
    <content type="text"></content>
      <categories>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot与swagger]]></title>
    <url>%2F2017%2F05%2F11%2Fspringboot-swagger%2F</url>
    <content type="text"><![CDATA[springboot项目中使用swagger，快速生成api pom中引入1234567891011&lt;!-- swagger --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; swagger配置 支持在配置文件中配置是否显示api，需要显示api的接口uri。(此处使用到了在springboot中读取配置文件信息的知识。springboot读取配置文件)12345678910111213141516171819202122232425262728293031323334353637@EnableSwagger2@Componentpublic class Swagger2 &#123; @Autowired private BasicProperties basicProperties; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .enable(basicProperties.getSwaggerShow()) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.hfy&quot;))// .paths(PathSelectors.any()) //.paths(PathSelectors.regex(&quot;/ab/*&quot;)) .paths(path()) .build(); &#125; private Predicate&lt;String&gt; path() &#123; List&lt;Predicate&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(); for (String pattern : basicProperties.getSwaggerPatterns()) &#123; list.add(PathSelectors.regex(pattern)); &#125; return Predicates.or(list); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;APIs&quot;) .contact(&quot;hfy&quot;) .version(&quot;1.0&quot;) .build(); &#125;&#125; 待完成 暂时没做到：swagger中搜索不可用。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2F2017%2F05%2F11%2Flinux-command%2F</url>
    <content type="text"><![CDATA[linux常用命令，和安装一些软件 常用命令查看java程序是否启动：ps -ef | grep java杀掉进程： kill -9 4564 4564是进程号，通过上一个命令查看（第二列）启动jar包：java -jar test.jar在后台启动jar：sh start.sh 其中，start.sh是个脚本。里面内容是：1234test=`dirname &quot;$0&quot;`cd $testnohup java -jar test.jar 2&gt;&amp;1 &gt;/dev/null &amp;cd - 安装redis安装activemq]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdk生成https证书]]></title>
    <url>%2F2017%2F05%2F11%2Fjava-https-cert%2F</url>
    <content type="text"></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis中的mapper]]></title>
    <url>%2F2017%2F05%2F11%2Fmybatis-sql%2F</url>
    <content type="text"><![CDATA[插入后返回主键、关联查询、多参 xml格式插入后返回主键12&lt;insert id=&quot;insertAd&quot; parameterType=&quot;com.hfy.db.bean.Ad&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;&lt;/insert&gt; 多个参数 对于接口中多个请求参数，没有封装成对象12345678910111213// dao中:OrderDetail selectByTypeAndDate(@Param(&quot;type&quot;)Integer type, @Param(&quot;date&quot;)String date);// mapper中：&lt;select id=&quot;selectByTypeAndDate&quot; resultMap=&quot;orderDetailResult&quot; &gt; SELECT * FROM order_detail WHERE type = #&#123;type&#125; &lt;c:if test=&quot;type == 1&quot;&gt; and minPlayTime &gt; #&#123;date&#125; &lt;/c:if&gt; &lt;c:if test=&quot;type == 2&quot;&gt; and maxPlayTime &lt; #&#123;date&#125; &lt;/c:if&gt;&lt;/select&gt; 关联查询 123456&lt;resultMap type=&quot;com.hfy.db.bean.PayOrder&quot; id=&quot;payOrderResult&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;!-- 配置关联关系 --&gt; &lt;association property=&quot;user&quot; column=&quot;userId&quot; select=&quot;com.hfy.dao.UserDao.selectAdById&quot;&gt;&lt;/association&gt; &lt;/resultMap&gt; 注解格式插入后返回主键12@Insert(&quot;&quot;)@SelectKey(statement = &quot;SELECT LAST_INSERT_ID()&quot;, keyProperty = &quot;user.id&quot;, resultType = int.class, before = false)]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springmvc与swagger]]></title>
    <url>%2F2017%2F05%2F11%2Fspringmvc-swagger%2F</url>
    <content type="text"></content>
      <categories>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>swagger</tag>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中日期相关问题]]></title>
    <url>%2F2017%2F05%2F11%2Fhtml-date%2F</url>
    <content type="text"><![CDATA[1 日期转换2 日期增减]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>date</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springmvc+mybatis事务不起作用]]></title>
    <url>%2F2017%2F05%2F11%2Fspringmvc-transaction%2F</url>
    <content type="text"><![CDATA[http://blog.csdn.net/liuxiao723846/article/details/43483101]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php]]></title>
    <url>%2F2017%2F05%2F11%2Fphp%2F</url>
    <content type="text"></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面中json相关问题]]></title>
    <url>%2F2017%2F05%2F11%2Fhtml-json%2F</url>
    <content type="text"><![CDATA[1 json与字符串2 json与数组]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>json</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github搭建自己的网站]]></title>
    <url>%2F2017%2F03%2F25%2Fhexo-github%2F</url>
    <content type="text"><![CDATA[安装nodejs(官网下载安装包安装即可) 安装hexo 安装速度慢，可以使用淘宝镜像： npm install cnpm -g –registry=https://registry.npm.taobao.org12345 npm install hexo-cli -g npm install hexo --save npm install hexo-deployer-git --save hexo init npm install hexo的一些命令： hexo clean hexo generate hexo s hexo deploy 使用git部署hexo到github (1) github上创建一个仓库 仓库名称(Repository name)可以写成blog。github自动生成的网址会是：https://账户名称.github.io/仓库名称/ (2) git使用hexo deploy部署的时候，保证user.name和github账上上的账户名一致。 设置username：git config –global user.name “ff” 查看：git config –list 修改：vi ~/.gitconfig 按下i键，修改，dd删除一行，esc退出编辑。按住shift，wq保存 (3) 部署：hexo deploy 使用next主题 （网上很多，此处记下可能遇到的问题） (1) 使用中文语言： 修改（hexo安装目录_config.yml）文件：(不是themes\next_config.yml) language: zh-Hans (2) 侧边栏中只显示日志，并没有标签、分类： 因为是首次使用，并没有新建任何博客，使用hexo new “first blog”创建博客：123456---title: first blog date: 2017-03-25 13:53:30 tags: 写作 categories: 随笔 --- 可以看到侧边栏出现分类、标签。 (3) 部署到github上js、css找不到 修改（hexo安装目录_config.yml）文件： root: /blog/ #blog是你github上面的仓库名称 (4) 侧边栏的分类、标签无法点击： 执行命令hexo new categories，修改hexo\source\categories下的index.md文件：123456---title: 分类date: 2016-07-16 04:36:09type: &quot;categories&quot;comments: false--- 执行命令hexo new tags,修改hexo\source\tags下的index.md文件：123456---title: 标签云date: 2016-07-16 04:32:03type: &quot;tags&quot;comments: false--- 使用atom实现预览编辑文档 atom安装插件atom-hexo，速度很慢，可以使用本地安装： 在github上下载好后解压到C:\Users\cage.atom\packages，cmd打开命令行输入：apm install安装即可。 如果apm命令找不到，在环境变量中加入: C:\Users\hfyuser\AppData\Local\atom\bin atom自带markdown preview，编写md可以实时浏览。 参考置顶文章]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>